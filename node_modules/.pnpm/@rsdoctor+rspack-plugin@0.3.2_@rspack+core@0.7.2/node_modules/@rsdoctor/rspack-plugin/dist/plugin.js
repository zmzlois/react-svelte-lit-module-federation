"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var plugin_exports = {};
__export(plugin_exports, {
  RsdoctorRspackPlugin: () => RsdoctorRspackPlugin
});
module.exports = __toCommonJS(plugin_exports);
var import_graph = require("@rsdoctor/graph");
var import_sdk = require("@rsdoctor/sdk");
var import_plugins = require("@rsdoctor/core/plugins");
var import_types = require("@rsdoctor/types");
var import_path = __toESM(require("path"));
var import_constants = require("./constants");
var import_lodash = require("lodash");
var import_probeLoaderPlugin = require("./probeLoaderPlugin");
var import_common = require("@rsdoctor/utils/common");
class RsdoctorRspackPlugin {
  constructor(options) {
    this.name = import_constants.pluginTapName;
    this.browserIsOpened = false;
    this.done = async (compiler) => {
      this.getRspackConfig(compiler);
      await this.sdk.bootstrap();
      this.sdk.addClientRoutes([
        import_types.Manifest.RsdoctorManifestClientRoutes.Overall
      ]);
      if (this.outsideInstance && "parent" in this.sdk) {
        this.sdk.parent.master.setOutputDir(
          import_path.default.resolve(
            compiler.outputPath,
            `./${import_types.Constants.RsdoctorOutputFolder}`
          )
        );
      }
      this.sdk.setOutputDir(
        import_path.default.resolve(compiler.outputPath, `./${import_types.Constants.RsdoctorOutputFolder}`)
      );
      await this.sdk.writeStore();
      if (!this.options.disableClientServer) {
        await this.sdk.server.openClientPage("homepage");
      }
      if (this.options.disableClientServer) {
        await this.sdk.dispose();
      }
    };
    this.options = (0, import_plugins.normalizeUserConfig)(options);
    this.sdk = this.options.sdkInstance ?? new import_sdk.RsdoctorWebpackSDK({
      port: this.options.port,
      name: import_constants.pluginTapName,
      root: process.cwd(),
      type: this.options.reportCodeType,
      config: { disableTOSUpload: this.options.disableTOSUpload },
      innerClientPath: this.options.innerClientPath
    });
    this.outsideInstance = Boolean(this.options.sdkInstance);
    this.modulesGraph = new import_graph.ModuleGraph();
  }
  apply(compiler) {
    if (!this._bootstrapTask) {
      this._bootstrapTask = this.sdk.bootstrap();
    }
    if (compiler.options.name) {
      this.sdk.setName(compiler.options.name);
    }
    (0, import_plugins.setSDK)(this.sdk);
    compiler.hooks.done.tapPromise(
      {
        ...import_constants.pluginTapPostOptions,
        stage: import_constants.pluginTapPostOptions.stage + 100
      },
      this.done.bind(this, compiler)
    );
    new import_plugins.InternalSummaryPlugin(this).apply(compiler);
    if (this.options.features.loader && !import_common.Loader.isVue(compiler)) {
      new import_probeLoaderPlugin.ProbeLoaderPlugin().apply(compiler);
      new import_plugins.InternalLoaderPlugin(this).apply(compiler);
    }
    if (this.options.features.plugins) {
      new import_plugins.InternalPluginsPlugin(this).apply(compiler);
    }
    if (this.options.features.bundle) {
      new import_plugins.InternalBundlePlugin(this).apply(compiler);
      new import_plugins.InternalBundleTagPlugin(this).apply(compiler);
    }
    new import_plugins.InternalRulesPlugin(this).apply(compiler);
    new import_plugins.InternalErrorReporterPlugin(this).apply(compiler);
  }
  /**
   * @description Generate ModuleGraph and ChunkGraph from stats and webpack module apis;
   * @param {Compiler} compiler
   * @return {*}
   * @memberof RsdoctorWebpackPlugin
   */
  ensureModulesChunksGraphApplied(compiler) {
    (0, import_plugins.ensureModulesChunksGraphFn)(compiler, this);
  }
  getRspackConfig(compiler) {
    if (compiler.isChild())
      return;
    const { plugins, infrastructureLogging, ...rest } = compiler.options;
    const _rest = (0, import_lodash.cloneDeep)(rest);
    (0, import_plugins.makeRulesSerializable)(_rest.module.defaultRules);
    (0, import_plugins.makeRulesSerializable)(_rest.module.rules);
    const configuration = {
      ..._rest,
      plugins: plugins.map((e) => e?.constructor.name)
    };
    const rspackVersion = compiler.webpack?.rspackVersion;
    const webpackVersion = compiler.webpack?.version;
    this.sdk.reportConfiguration({
      name: rspackVersion ? "rspack" : "webpack",
      version: rspackVersion || webpackVersion || "unknown",
      config: configuration
    });
    this.sdk.setOutputDir(
      import_path.default.resolve(compiler.outputPath, `./${import_types.Constants.RsdoctorOutputFolder}`)
    );
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RsdoctorRspackPlugin
});
