"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var core_exports = {};
__export(core_exports, {
  SDKCore: () => SDKCore
});
module.exports = __toCommonJS(core_exports);
var import_types = require("@rsdoctor/types");
var import_build = require("@rsdoctor/utils/build");
var import_common = require("@rsdoctor/utils/common");
var import_path = __toESM(require("path"));
var import_crypto = require("crypto");
var import_process = __toESM(require("process"));
var import_tapable = require("tapable");
var import_logger = require("@rsdoctor/utils/logger");
var import_utils = require("../utils");
class SDKCore {
  constructor({ name, root }) {
    this.hooks = {
      afterSaveManifest: new import_tapable.AsyncSeriesHook(["result"])
    };
    this._envinfo = {};
    this._clientRoutes = /* @__PURE__ */ new Set([
      import_types.Manifest.RsdoctorManifestClientRoutes.Overall
    ]);
    this.diskManifestPath = "";
    this._name = name;
    this.root = root;
    this.pid = import_process.default.pid;
    this._outputDir = import_path.default.join(this.root, import_types.Constants.RsdoctorOutputFolder);
  }
  get outputDir() {
    return this._outputDir;
  }
  get name() {
    return this._name;
  }
  async bootstrap() {
    const [cpu, memory, nodeVersion, yarnVersion, npmVersion, pnpmVersion] = await Promise.all([
      import_build.EnvInfo.getCPUInfo(),
      import_build.EnvInfo.getMemoryInfo(),
      import_build.EnvInfo.getNodeVersion(),
      import_build.EnvInfo.getYarnVersion(),
      import_build.EnvInfo.getNpmVersion(),
      import_build.EnvInfo.getPnpmVersion()
    ]);
    this._envinfo = {
      ...this._envinfo,
      cpu,
      memory,
      nodeVersion,
      yarnVersion,
      npmVersion,
      pnpmVersion
    };
    const hash = (0, import_crypto.createHash)("md5").update(
      [this.name, this.root, JSON.stringify(this._envinfo), Date.now()].join(
        "_"
      )
    ).digest("hex");
    this.setHash(hash);
  }
  async dispose() {
  }
  setOutputDir(outputDir) {
    this._outputDir = outputDir;
  }
  setName(name) {
    this._name = name;
  }
  setHash(hash) {
    this.hash = hash;
  }
  getHash() {
    return this.hash;
  }
  getClientRoutes() {
    return [...this._clientRoutes];
  }
  addClientRoutes(routes) {
    routes.forEach((route) => {
      this._clientRoutes.add(route);
    });
    this.onDataReport();
  }
  /** Upload analysis data pieces */
  async writePieces(storeData, _options) {
    const { outputDir } = this;
    const manifest = import_path.default.resolve(outputDir, import_types.Constants.RsdoctorOutputManifest);
    this.diskManifestPath = manifest;
    await import_build.File.fse.ensureDir(outputDir);
    const dataUrls = await Promise.all(
      Object.keys(storeData).map(async (key) => {
        const data = storeData[key];
        if (typeof data !== "object") {
          return {
            name: key,
            files: data
          };
        }
        const jsonstr = await (async () => {
          try {
            return JSON.stringify(data);
          } catch (error) {
            return import_build.Json.stringify(data);
          }
        })();
        return this.writeToFolder(jsonstr, outputDir, key);
      })
    );
    (0, import_logger.debug)(
      () => `SDKCore.writePieces extraConfig: ${JSON.stringify(this.extraConfig)}`,
      "[SDKCore.writePieces]"
    );
    this.cloudData = {
      client: {
        enableRoutes: this.getClientRoutes()
      },
      data: (0, import_utils.transformDataUrls)(dataUrls)
    };
  }
  /** Upload manifest file */
  async writeManifest() {
    const { cloudData: data, diskManifestPath } = this;
    const dataStr = JSON.stringify(data, null, 2);
    (0, import_logger.debug)(
      () => `SDKCore.writeManifest extraConfig: ${this.extraConfig}`,
      "[SDKCore.writeManifest]"
    );
    await Promise.all([import_build.File.fse.writeFile(diskManifestPath, dataStr)]);
    return diskManifestPath;
  }
  async saveManifest(data, options) {
    await this.writePieces(data, options);
    const manifestDiskPath = await this.writeManifest();
    await this.hooks.afterSaveManifest.promise({
      manifestWithShardingFiles: this.cloudData,
      manifestDiskPath
    });
    return manifestDiskPath;
  }
  writeToFolder(jsonstr, dir, key) {
    const sharding = new import_build.File.FileSharding(import_common.Algorithm.compressText(jsonstr));
    const folder = import_path.default.resolve(dir, key);
    const writer = sharding.writeStringToFolder(folder);
    return writer.then((item) => {
      const res = {
        name: key,
        files: item.map((el) => ({
          path: import_path.default.resolve(folder, el.filename),
          basename: el.filename,
          content: el.content
        }))
      };
      return res;
    });
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SDKCore
});
