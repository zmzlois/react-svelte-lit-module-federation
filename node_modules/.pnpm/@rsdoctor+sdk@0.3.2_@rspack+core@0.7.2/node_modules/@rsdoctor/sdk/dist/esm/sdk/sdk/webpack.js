import { DevToolError } from "@rsdoctor/utils/error";
import { SDK } from "@rsdoctor/types";
import { File } from "@rsdoctor/utils/build";
import { SourceMapConsumer } from "source-map";
import { ModuleGraph, ChunkGraph, PackageGraph } from "@rsdoctor/graph";
import { debug } from "@rsdoctor/utils/logger";
import { RsdoctorServer } from "../server";
import { RsdoctorFakeServer } from "../server/fakeServer";
import { SDKCore } from "./core";
class RsdoctorWebpackSDK extends SDKCore {
  constructor(options) {
    super(options);
    this._summary = { costs: [] };
    this._configs = [];
    this._errors = [];
    this._loader = [];
    this._loaderStart = [];
    this._resolver = [];
    this._plugin = {};
    this._moduleGraph = new ModuleGraph();
    this._chunkGraph = new ChunkGraph();
    this._rawSourceMapCache = /* @__PURE__ */ new Map();
    this._sourceMap = /* @__PURE__ */ new Map();
    this.server = options.noServer ? new RsdoctorFakeServer(this, void 0) : new RsdoctorServer(this, options.port, options.innerClientPath);
    this.type = options.type || SDK.ToDataType.Normal;
    this.extraConfig = options.config;
  }
  async bootstrap() {
    debug(() => `${Date.now()}`, "[RsdoctorWebpackSDK][bootstrap start]");
    this.server && await this.server.bootstrap();
    await super.bootstrap();
    debug(
      () => `${Date.now()} ${this.server.origin}`,
      "[RsdoctorWebpackSDK][bootstrap end]"
    );
  }
  async dispose() {
    debug(() => `${Date.now()}`, "[RsdoctorWebpackSDK][dispose start]");
    this.server && await this.server.dispose();
    await super.dispose();
    debug(() => `${Date.now()}`, "[RsdoctorWebpackSDK][dispose end]");
  }
  async applyErrorFix(id) {
    const { _errors: errors } = this;
    const error = errors.find((err) => err.id === id);
    if (!error || !error.path || !error.fixData || error.fixData.isFixed) {
      return;
    }
    const { path: filePath, fixData } = error;
    const sameFileErrors = errors.filter(
      (item) => item.path === filePath && item !== error
    );
    let content = (await File.fse.readFile(filePath, "utf-8")).toString();
    const startTxt = content.substring(0, fixData.start);
    const endTxt = content.substring(fixData.end, content.length);
    const offset = (fixData.newText ?? "").length - (fixData.end - fixData.start);
    content = startTxt + fixData.newText + endTxt;
    for (const other of sameFileErrors) {
      const { fixData: otherFixData } = other;
      if (!otherFixData) {
        continue;
      }
      if (otherFixData.start >= fixData.end) {
        otherFixData.start += offset;
        otherFixData.end += offset;
      }
    }
    await File.fse.writeFile(filePath, content);
  }
  clear() {
    this._errors = [];
    this._loader = [];
    this._resolver = [];
    this._plugin = {};
    this._moduleGraph = new ModuleGraph();
    this._chunkGraph = new ChunkGraph();
  }
  clearSourceMapCache() {
    this._rawSourceMapCache = /* @__PURE__ */ new Map();
    this._sourceMap = /* @__PURE__ */ new Map();
  }
  async getSourceMap(file) {
    const { _sourceMap: sourceMap, _rawSourceMapCache: rawMap } = this;
    if (sourceMap.has(file)) {
      return sourceMap.get(file);
    }
    const rawData = rawMap.get(file);
    if (!rawData || rawData.version < 0 || !rawData.sourcesContent?.[0] || !rawData.mappings) {
      return Promise.resolve(void 0);
    }
    try {
      const result = await new SourceMapConsumer(rawData);
      sourceMap.set(file, result);
      return result;
    } catch (e) {
      return Promise.resolve(void 0);
    }
  }
  reportSourceMap(data) {
    this._rawSourceMapCache.set(data.file, data);
  }
  reportConfiguration(config) {
    this._configs.push(config);
    this.onDataReport();
  }
  reportError(errors) {
    errors.forEach((item) => {
      this._errors.push(
        DevToolError.from(item, {
          code: this.name
        })
      );
    });
    this.onDataReport();
  }
  reportLoader(data) {
    data.forEach((item) => {
      let match = this._loader.find(
        (e) => e.resource.path === item.resource.path
      );
      if (match) {
        match.loaders.push(...item.loaders);
      } else {
        match = item;
        this._loader.push(item);
      }
      match.loaders.sort((a, b) => {
        if (a.startAt !== b.startAt) {
          return a.startAt - b.startAt;
        }
        if (a.isPitch) {
          if (b.isPitch) {
            return a.loaderIndex - b.loaderIndex;
          }
          return -1;
        }
        if (b.isPitch) {
          return 1;
        }
        return b.loaderIndex - a.loaderIndex;
      });
    });
    this.onDataReport();
  }
  reportLoaderStartOrEnd(data) {
    const _builtinLoader = data.loaders[0];
    if (_builtinLoader.startAt) {
      this._loaderStart.push(data);
    } else if (_builtinLoader.endAt) {
      const matchLoaderStart = this._loaderStart.find(
        (e) => e.resource.path === data.resource.path && e.loaders[0].loader === _builtinLoader.loader
      );
      if (matchLoaderStart) {
        matchLoaderStart.loaders[0].result = _builtinLoader.result;
        matchLoaderStart.loaders[0].endAt = _builtinLoader.endAt;
        this.reportLoader([matchLoaderStart]);
      }
    }
  }
  reportResolver(data) {
    data.forEach((item) => this._resolver.push(item));
    this.onDataReport();
  }
  reportPlugin(data) {
    Object.keys(data).forEach((hook) => {
      if (!this._plugin[hook]) {
        this._plugin[hook] = data[hook];
      } else {
        data[hook].forEach((item) => {
          this._plugin[hook].push(item);
        });
      }
    });
    this.onDataReport();
  }
  reportModuleGraph(data) {
    debug(() => `data size: ${data.size()}`, "[SDK.reportModuleGraph][start]");
    this._moduleGraph.fromInstance(data);
    this.createPackageGraph();
    this.onDataReport();
    debug(
      () => `sdk._moduleGraph size: ${this._moduleGraph.size()}`,
      "[SDK reportModuleGraph][end]"
    );
  }
  reportPackageGraph(data) {
    debug(() => "[SDK.reportPackageGraph][start]");
    if (!this._packageGraph) {
      this._packageGraph = data;
    }
    this.onDataReport();
    debug(
      () => `sdk._moduleGraph size: ${this._moduleGraph.size()}`,
      "[SDK reportPackageGraph][end]"
    );
  }
  reportChunkGraph(data) {
    this._chunkGraph.addAsset(...data.getAssets());
    this._chunkGraph.addChunk(...data.getChunks());
    this._chunkGraph.addEntryPoint(...data.getEntryPoints());
    this.onDataReport();
  }
  reportSummaryData(part) {
    const keys = ["costs"];
    for (const key of keys) {
      const v = part[key];
      if (!v)
        continue;
      if (typeof v === "object") {
        if (Array.isArray(v)) {
          this._summary[key] = [
            ...this._summary[key] || [],
            ...v
          ];
        } else {
          this._summary[key] = {
            ...this._summary[key] || {},
            ...v
          };
        }
      } else {
        this._summary[key] = v;
      }
    }
    this.onDataReport();
  }
  reportTileHtml(tileReportHtml) {
    this._tileReportHtml = tileReportHtml;
  }
  createPackageGraph() {
    debug(
      () => `sdk._moduleGraph size: ${this._moduleGraph.size()}`,
      "[SDK.createPackageGraph][start]"
    );
    if (!this._packageGraph) {
      const pkgGraph = PackageGraph.fromModuleGraph(
        this._moduleGraph,
        this.root,
        (path) => {
          try {
            const exists = File.fse.existsSync(path);
            if (exists) {
              debug(
                () => `sdk.PackageGraph package.json exists: ${exists}, path: ${path}`,
                "[SDK.createPackageGraph][load]"
              );
              return File.fse.readJSONSync(path);
            }
          } catch (error) {
            const { message, stack } = error;
            debug(
              () => `sdk.createPackageGraph error, path: ${path}, error message: ${stack || message}`,
              "[SDK.createPackageGraph][error]"
            );
          }
        }
      );
      this._packageGraph = pkgGraph;
      debug(
        () => `sdk._packageGraph packages: ${this._packageGraph.getPackages().length}`,
        "[SDK.createPackageGraph][end]"
      );
    }
  }
  writeStore(options) {
    debug(() => `sdk.writeStore has run.`, "[SDK.writeStore][end]");
    return this.saveManifest(this.getStoreData(), options || {});
  }
  getStoreData() {
    const ctx = this;
    return {
      get hash() {
        return ctx.hash;
      },
      get root() {
        return ctx.root;
      },
      get envinfo() {
        return ctx._envinfo;
      },
      get pid() {
        return ctx.pid;
      },
      get errors() {
        return ctx._errors.map((err) => err.toData());
      },
      get configs() {
        return ctx._configs.slice();
      },
      get summary() {
        return { ...ctx._summary };
      },
      get resolver() {
        return ctx._resolver.slice();
      },
      get loader() {
        return ctx._loader.slice();
      },
      get moduleGraph() {
        return ctx._moduleGraph.toData({
          contextPath: ctx._configs?.[0]?.config?.context || ""
        });
      },
      get chunkGraph() {
        return ctx._chunkGraph.toData(ctx.type);
      },
      get moduleCodeMap() {
        return ctx._moduleGraph.toCodeData(ctx.type);
      },
      get plugin() {
        return { ...ctx._plugin };
      },
      get packageGraph() {
        return ctx._packageGraph ? ctx._packageGraph.toData() : {
          packages: [],
          dependencies: []
        };
      },
      get otherReports() {
        return { tileReportHtml: ctx._tileReportHtml || "" };
      }
    };
  }
  getManifestData() {
    const dataValue = this.getStoreData();
    const data = {
      client: {
        enableRoutes: this.getClientRoutes()
      },
      data: Object.keys(dataValue).reduce((t, e) => {
        const _e = e;
        if (dataValue[_e] && typeof dataValue[_e] === "object") {
          t[e] = [
            `${this.server.origin}${SDK.ServerAPI.API.LoadDataByKey}/${e}`
          ];
        } else {
          t[e] = dataValue[_e];
        }
        return t;
      }, {}),
      __LOCAL__SERVER__: true,
      __SOCKET__URL__: this.server.socketUrl
    };
    return data;
  }
  getRuleContext(_options) {
    this.createPackageGraph();
    return {
      root: this.root,
      errors: this._errors.slice(),
      configs: this._configs.slice(),
      moduleGraph: this._moduleGraph,
      chunkGraph: this._chunkGraph,
      packageGraph: this._packageGraph,
      loader: this._loader.slice(),
      otherReports: { tileReportHtml: this._tileReportHtml || "" }
    };
  }
  onDataReport() {
    this.server.broadcast();
  }
}
export {
  RsdoctorWebpackSDK
};
