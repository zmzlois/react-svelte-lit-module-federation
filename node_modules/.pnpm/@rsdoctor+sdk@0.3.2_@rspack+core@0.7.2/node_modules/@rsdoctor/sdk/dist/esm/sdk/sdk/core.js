import { Constants, Manifest } from "@rsdoctor/types";
import { File, Json, EnvInfo } from "@rsdoctor/utils/build";
import { Algorithm } from "@rsdoctor/utils/common";
import path from "path";
import { createHash } from "crypto";
import process from "process";
import { AsyncSeriesHook } from "tapable";
import { debug } from "@rsdoctor/utils/logger";
import { transformDataUrls } from "../utils";
class SDKCore {
  constructor({ name, root }) {
    this.hooks = {
      afterSaveManifest: new AsyncSeriesHook(["result"])
    };
    this._envinfo = {};
    this._clientRoutes = /* @__PURE__ */ new Set([
      Manifest.RsdoctorManifestClientRoutes.Overall
    ]);
    this.diskManifestPath = "";
    this._name = name;
    this.root = root;
    this.pid = process.pid;
    this._outputDir = path.join(this.root, Constants.RsdoctorOutputFolder);
  }
  get outputDir() {
    return this._outputDir;
  }
  get name() {
    return this._name;
  }
  async bootstrap() {
    const [cpu, memory, nodeVersion, yarnVersion, npmVersion, pnpmVersion] = await Promise.all([
      EnvInfo.getCPUInfo(),
      EnvInfo.getMemoryInfo(),
      EnvInfo.getNodeVersion(),
      EnvInfo.getYarnVersion(),
      EnvInfo.getNpmVersion(),
      EnvInfo.getPnpmVersion()
    ]);
    this._envinfo = {
      ...this._envinfo,
      cpu,
      memory,
      nodeVersion,
      yarnVersion,
      npmVersion,
      pnpmVersion
    };
    const hash = createHash("md5").update(
      [this.name, this.root, JSON.stringify(this._envinfo), Date.now()].join(
        "_"
      )
    ).digest("hex");
    this.setHash(hash);
  }
  async dispose() {
  }
  setOutputDir(outputDir) {
    this._outputDir = outputDir;
  }
  setName(name) {
    this._name = name;
  }
  setHash(hash) {
    this.hash = hash;
  }
  getHash() {
    return this.hash;
  }
  getClientRoutes() {
    return [...this._clientRoutes];
  }
  addClientRoutes(routes) {
    routes.forEach((route) => {
      this._clientRoutes.add(route);
    });
    this.onDataReport();
  }
  /** Upload analysis data pieces */
  async writePieces(storeData, _options) {
    const { outputDir } = this;
    const manifest = path.resolve(outputDir, Constants.RsdoctorOutputManifest);
    this.diskManifestPath = manifest;
    await File.fse.ensureDir(outputDir);
    const dataUrls = await Promise.all(
      Object.keys(storeData).map(async (key) => {
        const data = storeData[key];
        if (typeof data !== "object") {
          return {
            name: key,
            files: data
          };
        }
        const jsonstr = await (async () => {
          try {
            return JSON.stringify(data);
          } catch (error) {
            return Json.stringify(data);
          }
        })();
        return this.writeToFolder(jsonstr, outputDir, key);
      })
    );
    debug(
      () => `SDKCore.writePieces extraConfig: ${JSON.stringify(this.extraConfig)}`,
      "[SDKCore.writePieces]"
    );
    this.cloudData = {
      client: {
        enableRoutes: this.getClientRoutes()
      },
      data: transformDataUrls(dataUrls)
    };
  }
  /** Upload manifest file */
  async writeManifest() {
    const { cloudData: data, diskManifestPath } = this;
    const dataStr = JSON.stringify(data, null, 2);
    debug(
      () => `SDKCore.writeManifest extraConfig: ${this.extraConfig}`,
      "[SDKCore.writeManifest]"
    );
    await Promise.all([File.fse.writeFile(diskManifestPath, dataStr)]);
    return diskManifestPath;
  }
  async saveManifest(data, options) {
    await this.writePieces(data, options);
    const manifestDiskPath = await this.writeManifest();
    await this.hooks.afterSaveManifest.promise({
      manifestWithShardingFiles: this.cloudData,
      manifestDiskPath
    });
    return manifestDiskPath;
  }
  writeToFolder(jsonstr, dir, key) {
    const sharding = new File.FileSharding(Algorithm.compressText(jsonstr));
    const folder = path.resolve(dir, key);
    const writer = sharding.writeStringToFolder(folder);
    return writer.then((item) => {
      const res = {
        name: key,
        files: item.map((el) => ({
          path: path.resolve(folder, el.filename),
          basename: el.filename,
          content: el.content
        }))
      };
      return res;
    });
  }
}
export {
  SDKCore
};
