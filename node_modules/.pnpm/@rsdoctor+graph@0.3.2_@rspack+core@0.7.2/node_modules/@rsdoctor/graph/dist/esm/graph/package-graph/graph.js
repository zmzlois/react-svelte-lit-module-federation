import { unionBy } from "lodash";
import { dirname, join, resolve } from "path";
import { SDK } from "@rsdoctor/types";
import { Package as PackageUtil } from "@rsdoctor/utils/common";
import { Package } from "./package";
import { PackageDependency } from "./dependency";
class PackageGraph {
  constructor(root) {
    this._dependencies = [];
    this._packages = [];
    this._pkgNameMap = /* @__PURE__ */ new Map();
    this._pkgFileMap = /* @__PURE__ */ new Map();
    this._root = root;
  }
  static fromModuleGraph(graph, root, getPackageFile) {
    const pkgGraph = new PackageGraph(root);
    const modules = graph.getModules().filter((item) => item.kind === SDK.ModuleKind.Normal);
    for (const item of modules) {
      const pkg = pkgGraph.getPackageByModule(item, getPackageFile);
      if (pkg) {
        pkgGraph.addPackage(pkg);
        pkg.addModule(item);
      }
    }
    for (const dep of graph.getDependencies()) {
      const modulePkg = pkgGraph.getPackageByFile(dep.module.path);
      const dependencyPkg = pkgGraph.getPackageByFile(dep.dependency.path);
      if (modulePkg && dependencyPkg && !modulePkg.isSame(dependencyPkg)) {
        const pkgDep = new PackageDependency(modulePkg, dependencyPkg, dep);
        pkgGraph.addDependency(pkgDep);
        modulePkg.addDependency(pkgDep);
      }
    }
    return pkgGraph;
  }
  getPackages() {
    return this._packages.slice();
  }
  getPackageByModule(module, readFile) {
    const { path: file, meta } = module;
    const { _pkgFileMap: pkgsMap } = this;
    const getPackageByData = (data2) => {
      return this.getPackageByData(data2) ?? new Package(data2.name, data2.root, data2.version);
    };
    if (pkgsMap.has(file)) {
      return pkgsMap.get(file);
    }
    if (meta.packageData) {
      const pkg2 = getPackageByData(meta.packageData);
      pkgsMap.set(file, pkg2);
      return pkg2;
    }
    const readPackageJson = (file2, readFile2) => {
      let result;
      let current = file2;
      while (current !== "/" && !result) {
        if (dirname(current) === current) {
          break;
        }
        current = dirname(current);
        if (readFile2) {
          result = readFile2(join(current, "package.json"));
        }
        if (!readFile2) {
          result = PackageUtil.getPackageMetaFromModulePath(file2);
        } else if (!result?.name) {
          result = void 0;
        }
      }
      if (!result) {
        return;
      }
      if (readFile2 && (!result.name || !result.version)) {
        return readPackageJson(dirname(current), readFile2);
      }
      return {
        ...result,
        root: current
      };
    };
    const cache = this.getPackageContainFile(file);
    if (cache) {
      pkgsMap.set(file, cache);
      return cache;
    }
    const data = readPackageJson(file, readFile);
    if (!data) {
      return;
    }
    if (data.root.startsWith(".")) {
      data.root = resolve(this._root, data.root);
    }
    const pkg = getPackageByData(data);
    this.addPackage(pkg);
    pkgsMap.set(file, pkg);
    return pkg;
  }
  getPackageByFile(file) {
    return this._pkgFileMap.get(file);
  }
  getPackageContainFile(file) {
    return this._packages.find((pkg) => pkg.contain(file));
  }
  getPackagesByName(name) {
    return this._pkgNameMap.get(name) ?? [];
  }
  getPackageByData(data) {
    return this._pkgNameMap.get(data.name)?.find(
      (item) => item.version === data.version && item.root === data.root
    );
  }
  addPackage(pkg) {
    if (this._packages.every((item) => !item.isSame(pkg))) {
      this._packages.push(pkg);
      const { _pkgNameMap: map } = this;
      const arr = map.get(pkg.name) ?? [];
      if (arr.every((item) => !item.isSame(pkg))) {
        arr.push(pkg);
        map.set(pkg.name, arr);
      }
    }
  }
  getDependenciesFromPackage(pkg) {
    return this._dependencies.filter((dep) => dep.dependency === pkg);
  }
  addDependency(dep) {
    if (this._dependencies.every((item) => !item.isSame(dep))) {
      this._dependencies.push(dep);
    }
  }
  getDependenciesFromOrigin() {
    return this._dependencies.filter((item) => !item.package);
  }
  getDuplicatePackages() {
    return unionBy(
      Array.from(this._pkgNameMap.values()).map((pkgs) => {
        return unionBy(pkgs, "version");
      }).filter((pkgs) => pkgs.length > 1),
      (pkgs) => pkgs[0].name
    );
  }
  toData() {
    return {
      packages: this._packages.map((e) => e.toData()),
      dependencies: this._dependencies.map((d) => d.toData())
    };
  }
}
export {
  PackageGraph
};
