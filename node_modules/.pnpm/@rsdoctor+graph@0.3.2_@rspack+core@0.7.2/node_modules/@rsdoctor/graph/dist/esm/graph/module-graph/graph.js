import { SDK } from "@rsdoctor/types";
import { Dependency } from "./dependency";
import { Module } from "./module";
import { Statement } from "./statement";
import {
  ModuleGraphModule,
  ExportInfo,
  SideEffect,
  Variable
} from "./tree-shaking";
class ModuleGraph {
  constructor() {
    this._dependenciesIdMap = /* @__PURE__ */ new Map();
    this._moduleWebpackIdMap = /* @__PURE__ */ new Map();
    this._moduleIdMap = /* @__PURE__ */ new Map();
    this._moduleGraphModules = /* @__PURE__ */ new Map();
    this._exportIdMap = /* @__PURE__ */ new Map();
    this._sideEffectIdMap = /* @__PURE__ */ new Map();
    this._varIdMap = /* @__PURE__ */ new Map();
  }
  static init() {
    Module.init();
    Dependency.init();
    ModuleGraphModule.init();
  }
  static fromData(data) {
    const moduleGraph = new ModuleGraph();
    const getStatement = (data2) => new Statement(moduleGraph.getModuleById(data2.module), data2.position);
    for (const item of data.modules ?? []) {
      const module = new Module(
        String(item.id),
        item.path,
        item.isEntry,
        item.kind
      );
      module.id = item.id;
      module.setSize(item.size);
      module.meta = {
        strictHarmonyModule: item.meta?.strictHarmonyModule ?? false,
        hasSetEsModuleStatement: item.meta?.hasSetEsModuleStatement ?? false
      };
      module._isPreferSource = item.isPreferSource;
      module.chunks = item.chunks;
      moduleGraph.addModule(module);
    }
    for (const moduleData of data.modules ?? []) {
      const module = moduleGraph.getModuleById(moduleData.id);
      for (const depId of moduleData.dependencies) {
        const depData = (data.dependencies ?? []).find(
          (item) => item.id === depId
        );
        const depModule = depData && moduleGraph.getModuleById(depData.originDependency);
        if (!depData || !depModule) {
          console.warn(`The connection data ID is empty: ${depId}`);
          continue;
        }
        const dep = module.addDependency(
          depData.request,
          depModule,
          depData.kind,
          depData.statements.map(getStatement)
        );
        if (!dep) {
          continue;
        }
        dep.id = depData.id;
        moduleGraph.addDependency(dep);
      }
      for (const normalModuleId of moduleData.modules ?? []) {
        const normalModule = moduleGraph.getModuleById(normalModuleId);
        if (!normalModule) {
          console.warn(
            `Add the ordinary module ID as empty: ${normalModuleId}`
          );
          continue;
        }
        module.addNormalModule(normalModule);
      }
      for (const concatenationModuleId of moduleData.concatenationModules ?? []) {
        const concatenationModule = moduleGraph.getModuleById(
          concatenationModuleId
        );
        if (!concatenationModule) {
          console.warn(
            `The aggregation module ID is empty: ${concatenationModule}`
          );
          continue;
        }
        module.addConcatenationModule(concatenationModule);
      }
    }
    for (const exportData of data.exports ?? []) {
      const info = new ExportInfo(
        exportData.name,
        exportData.identifier ? getStatement(exportData.identifier) : void 0
      );
      info.id = exportData.id;
      moduleGraph.addExportInfo(info);
    }
    for (const exportData of data.exports ?? []) {
      if (exportData.from) {
        const current = moduleGraph._exportIdMap.get(exportData.id);
        const from = moduleGraph._exportIdMap.get(exportData.from);
        if (current && from) {
          current.setFromExport(from);
        }
      }
    }
    for (const varData of data.variables ?? []) {
      const module = moduleGraph.getModuleById(varData.module);
      if (!module) {
        console.warn(
          `The module ID in the variable is empty：${varData.module}`
        );
        continue;
      }
      const info = new Variable(
        varData.name,
        module,
        varData.usedInfo,
        getStatement(varData.identifier)
      );
      const exportInfo = moduleGraph._exportIdMap.get(varData.exported ?? -1);
      if (exportInfo) {
        info.setExportInfo(exportInfo);
      }
      info.id = varData.id;
      moduleGraph.addVariable(info);
    }
    for (const sideData of data.sideEffects ?? []) {
      const module = moduleGraph.getModuleById(sideData.module);
      if (!module) {
        console.warn(
          `The module ID in the side effects is empty：${sideData.module}`
        );
        continue;
      }
      const info = new SideEffect(
        sideData.name,
        module,
        getStatement(sideData.identifier),
        sideData.originName
      );
      info.isNameSpace = sideData.isNameSpace;
      info.id = sideData.id;
      for (const exportId of sideData.exports ?? []) {
        const exportInfo = moduleGraph._exportIdMap.get(exportId);
        if (exportInfo) {
          exportInfo.addSideEffect(info);
        }
      }
      if (sideData.variable) {
        const varInfo = moduleGraph._varIdMap.get(sideData.variable);
        if (varInfo) {
          info._variable = varInfo;
        }
      }
      moduleGraph.addSideEffect(info);
    }
    for (const mgmData of data.moduleGraphModules ?? []) {
      const module = moduleGraph.getModuleById(mgmData.module);
      if (!module) {
        console.warn(
          `The module ID in ModuleGraphModule is empty: ${mgmData.module}`
        );
        continue;
      }
      const mgm = new ModuleGraphModule(module, moduleGraph, mgmData.dynamic);
      moduleGraph.addModuleGraphModule(mgm);
      mgmData.exports.forEach((id) => {
        const info = moduleGraph._exportIdMap.get(id);
        if (info) {
          mgm.addExportInfo(info);
        }
      });
      mgmData.sideEffects.forEach((id) => {
        const info = moduleGraph._sideEffectIdMap.get(id);
        if (info) {
          mgm.addSideEffect(info);
        }
      });
      mgmData.variables.forEach((id) => {
        const info = moduleGraph._varIdMap.get(id);
        if (info) {
          mgm.addVariable(info);
        }
      });
    }
    ModuleGraph.init();
    return moduleGraph;
  }
  clear() {
    this._dependenciesIdMap = /* @__PURE__ */ new Map();
    this._moduleWebpackIdMap = /* @__PURE__ */ new Map();
    this._moduleIdMap = /* @__PURE__ */ new Map();
    this._moduleGraphModules = /* @__PURE__ */ new Map();
    this._exportIdMap = /* @__PURE__ */ new Map();
    this._sideEffectIdMap = /* @__PURE__ */ new Map();
    this._varIdMap = /* @__PURE__ */ new Map();
  }
  size() {
    return this._moduleIdMap.size;
  }
  fromInstance(data) {
    this._dependenciesIdMap = new Map(data._dependenciesIdMap);
    this._moduleWebpackIdMap = new Map(data._moduleWebpackIdMap);
    this._moduleIdMap = new Map(data._moduleIdMap);
    this._moduleGraphModules = new Map(data._moduleGraphModules);
    this._exportIdMap = new Map(data._exportIdMap);
    this._sideEffectIdMap = new Map(data._sideEffectIdMap);
    this._varIdMap = new Map(data._varIdMap);
  }
  getSubGraphByModule(module) {
    const map = /* @__PURE__ */ new Set();
    const result = [module];
    map.add(module);
    for (let i = 0; i < result.length; i++) {
      const current = result[i];
      for (const { dependency: depModule } of current.getDependencies()) {
        if (map.has(depModule)) {
          continue;
        }
        map.add(depModule);
        result.push(depModule);
      }
    }
    return result;
  }
  getModules() {
    return Array.from(this._moduleWebpackIdMap.values());
  }
  getDependencies() {
    return Array.from(this._dependenciesIdMap.values());
  }
  getEntryModules() {
    return this.getModules().filter(
      (item) => item.isEntry && item.kind !== SDK.ModuleKind.Concatenation
    );
  }
  getModuleById(id) {
    return this._moduleIdMap.get(id);
  }
  getDependencyById(id) {
    return this._dependenciesIdMap.get(id);
  }
  getModuleByWebpackId(id) {
    return this._moduleWebpackIdMap.get(id);
  }
  getModuleByFile(file) {
    return this.getModules().find((item) => item.path === file);
  }
  addModule(...modules) {
    for (const module of modules) {
      if (!this._moduleIdMap.has(module.id)) {
        this._moduleWebpackIdMap.set(module.webpackId, module);
        this._moduleIdMap.set(module.id, module);
      }
    }
  }
  addDependency(...deps) {
    for (const dep of deps) {
      if (!this._dependenciesIdMap.has(dep.id)) {
        this._dependenciesIdMap.set(dep.id, dep);
        this.addModule(dep.module);
        this.addModule(dep.dependency);
      }
    }
  }
  removeModule(module) {
    this._moduleIdMap.delete(module.id);
    this._moduleWebpackIdMap.delete(module.webpackId);
    for (const dep of module.getDependencies()) {
      this.removeDependency(dep);
      this._dependenciesIdMap.delete(dep.id);
    }
    for (const imported of module.getImported()) {
      imported.removeDependencyByModule(imported);
    }
  }
  removeDependency(dep) {
    dep.module.removeDependency(dep);
    dep.dependency.removeImported(dep.module);
    this._dependenciesIdMap.delete(dep.id);
  }
  addModuleGraphModule(mgm) {
    if (!this._moduleGraphModules.has(mgm.module)) {
      this._moduleGraphModules.set(mgm.module, mgm);
    }
  }
  getModuleGraphModule(module) {
    return this._moduleGraphModules.get(module);
  }
  getModuleGraphModules() {
    return Array.from(this._moduleGraphModules.values());
  }
  addExportInfo(data) {
    this._exportIdMap.set(data.id, data);
  }
  addSideEffect(data) {
    this._sideEffectIdMap.set(data.id, data);
  }
  addVariable(data) {
    this._varIdMap.set(data.id, data);
  }
  toData(configs) {
    return {
      dependencies: this.getDependencies().map((item) => item.toData()),
      modules: this.getModules().map(
        (item) => item.toData(configs?.contextPath)
      ),
      moduleGraphModules: Array.from(this._moduleGraphModules.values()).map(
        (item) => item.toData()
      ),
      exports: Array.from(this._exportIdMap.values()).map(
        (item) => item.toData()
      ),
      sideEffects: Array.from(this._sideEffectIdMap.values()).map(
        (item) => item.toData()
      ),
      variables: Array.from(this._varIdMap.values()).map(
        (item) => item.toData()
      )
    };
  }
  toCodeData(type = SDK.ToDataType.Normal) {
    const codeMap = {};
    this.getModules().forEach((item) => {
      codeMap[item.id] = item.getSource(type);
    });
    return codeMap;
  }
}
export {
  ModuleGraph
};
