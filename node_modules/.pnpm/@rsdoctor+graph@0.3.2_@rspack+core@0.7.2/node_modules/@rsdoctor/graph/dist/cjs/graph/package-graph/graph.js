"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var graph_exports = {};
__export(graph_exports, {
  PackageGraph: () => PackageGraph
});
module.exports = __toCommonJS(graph_exports);
var import_lodash = require("lodash");
var import_path = require("path");
var import_types = require("@rsdoctor/types");
var import_common = require("@rsdoctor/utils/common");
var import_package = require("./package");
var import_dependency = require("./dependency");
class PackageGraph {
  constructor(root) {
    this._dependencies = [];
    this._packages = [];
    this._pkgNameMap = /* @__PURE__ */ new Map();
    this._pkgFileMap = /* @__PURE__ */ new Map();
    this._root = root;
  }
  static fromModuleGraph(graph, root, getPackageFile) {
    const pkgGraph = new PackageGraph(root);
    const modules = graph.getModules().filter((item) => item.kind === import_types.SDK.ModuleKind.Normal);
    for (const item of modules) {
      const pkg = pkgGraph.getPackageByModule(item, getPackageFile);
      if (pkg) {
        pkgGraph.addPackage(pkg);
        pkg.addModule(item);
      }
    }
    for (const dep of graph.getDependencies()) {
      const modulePkg = pkgGraph.getPackageByFile(dep.module.path);
      const dependencyPkg = pkgGraph.getPackageByFile(dep.dependency.path);
      if (modulePkg && dependencyPkg && !modulePkg.isSame(dependencyPkg)) {
        const pkgDep = new import_dependency.PackageDependency(modulePkg, dependencyPkg, dep);
        pkgGraph.addDependency(pkgDep);
        modulePkg.addDependency(pkgDep);
      }
    }
    return pkgGraph;
  }
  getPackages() {
    return this._packages.slice();
  }
  getPackageByModule(module2, readFile) {
    const { path: file, meta } = module2;
    const { _pkgFileMap: pkgsMap } = this;
    const getPackageByData = (data2) => {
      return this.getPackageByData(data2) ?? new import_package.Package(data2.name, data2.root, data2.version);
    };
    if (pkgsMap.has(file)) {
      return pkgsMap.get(file);
    }
    if (meta.packageData) {
      const pkg2 = getPackageByData(meta.packageData);
      pkgsMap.set(file, pkg2);
      return pkg2;
    }
    const readPackageJson = (file2, readFile2) => {
      let result;
      let current = file2;
      while (current !== "/" && !result) {
        if ((0, import_path.dirname)(current) === current) {
          break;
        }
        current = (0, import_path.dirname)(current);
        if (readFile2) {
          result = readFile2((0, import_path.join)(current, "package.json"));
        }
        if (!readFile2) {
          result = import_common.Package.getPackageMetaFromModulePath(file2);
        } else if (!result?.name) {
          result = void 0;
        }
      }
      if (!result) {
        return;
      }
      if (readFile2 && (!result.name || !result.version)) {
        return readPackageJson((0, import_path.dirname)(current), readFile2);
      }
      return {
        ...result,
        root: current
      };
    };
    const cache = this.getPackageContainFile(file);
    if (cache) {
      pkgsMap.set(file, cache);
      return cache;
    }
    const data = readPackageJson(file, readFile);
    if (!data) {
      return;
    }
    if (data.root.startsWith(".")) {
      data.root = (0, import_path.resolve)(this._root, data.root);
    }
    const pkg = getPackageByData(data);
    this.addPackage(pkg);
    pkgsMap.set(file, pkg);
    return pkg;
  }
  getPackageByFile(file) {
    return this._pkgFileMap.get(file);
  }
  getPackageContainFile(file) {
    return this._packages.find((pkg) => pkg.contain(file));
  }
  getPackagesByName(name) {
    return this._pkgNameMap.get(name) ?? [];
  }
  getPackageByData(data) {
    return this._pkgNameMap.get(data.name)?.find(
      (item) => item.version === data.version && item.root === data.root
    );
  }
  addPackage(pkg) {
    if (this._packages.every((item) => !item.isSame(pkg))) {
      this._packages.push(pkg);
      const { _pkgNameMap: map } = this;
      const arr = map.get(pkg.name) ?? [];
      if (arr.every((item) => !item.isSame(pkg))) {
        arr.push(pkg);
        map.set(pkg.name, arr);
      }
    }
  }
  getDependenciesFromPackage(pkg) {
    return this._dependencies.filter((dep) => dep.dependency === pkg);
  }
  addDependency(dep) {
    if (this._dependencies.every((item) => !item.isSame(dep))) {
      this._dependencies.push(dep);
    }
  }
  getDependenciesFromOrigin() {
    return this._dependencies.filter((item) => !item.package);
  }
  getDuplicatePackages() {
    return (0, import_lodash.unionBy)(
      Array.from(this._pkgNameMap.values()).map((pkgs) => {
        return (0, import_lodash.unionBy)(pkgs, "version");
      }).filter((pkgs) => pkgs.length > 1),
      (pkgs) => pkgs[0].name
    );
  }
  toData() {
    return {
      packages: this._packages.map((e) => e.toData()),
      dependencies: this._dependencies.map((d) => d.toData())
    };
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PackageGraph
});
