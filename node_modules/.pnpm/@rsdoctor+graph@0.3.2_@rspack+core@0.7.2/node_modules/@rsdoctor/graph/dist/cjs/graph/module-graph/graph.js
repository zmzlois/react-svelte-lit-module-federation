"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var graph_exports = {};
__export(graph_exports, {
  ModuleGraph: () => ModuleGraph
});
module.exports = __toCommonJS(graph_exports);
var import_types = require("@rsdoctor/types");
var import_dependency = require("./dependency");
var import_module = require("./module");
var import_statement = require("./statement");
var import_tree_shaking = require("./tree-shaking");
class ModuleGraph {
  constructor() {
    this._dependenciesIdMap = /* @__PURE__ */ new Map();
    this._moduleWebpackIdMap = /* @__PURE__ */ new Map();
    this._moduleIdMap = /* @__PURE__ */ new Map();
    this._moduleGraphModules = /* @__PURE__ */ new Map();
    this._exportIdMap = /* @__PURE__ */ new Map();
    this._sideEffectIdMap = /* @__PURE__ */ new Map();
    this._varIdMap = /* @__PURE__ */ new Map();
  }
  static init() {
    import_module.Module.init();
    import_dependency.Dependency.init();
    import_tree_shaking.ModuleGraphModule.init();
  }
  static fromData(data) {
    const moduleGraph = new ModuleGraph();
    const getStatement = (data2) => new import_statement.Statement(moduleGraph.getModuleById(data2.module), data2.position);
    for (const item of data.modules ?? []) {
      const module2 = new import_module.Module(
        String(item.id),
        item.path,
        item.isEntry,
        item.kind
      );
      module2.id = item.id;
      module2.setSize(item.size);
      module2.meta = {
        strictHarmonyModule: item.meta?.strictHarmonyModule ?? false,
        hasSetEsModuleStatement: item.meta?.hasSetEsModuleStatement ?? false
      };
      module2._isPreferSource = item.isPreferSource;
      module2.chunks = item.chunks;
      moduleGraph.addModule(module2);
    }
    for (const moduleData of data.modules ?? []) {
      const module2 = moduleGraph.getModuleById(moduleData.id);
      for (const depId of moduleData.dependencies) {
        const depData = (data.dependencies ?? []).find(
          (item) => item.id === depId
        );
        const depModule = depData && moduleGraph.getModuleById(depData.originDependency);
        if (!depData || !depModule) {
          console.warn(`The connection data ID is empty: ${depId}`);
          continue;
        }
        const dep = module2.addDependency(
          depData.request,
          depModule,
          depData.kind,
          depData.statements.map(getStatement)
        );
        if (!dep) {
          continue;
        }
        dep.id = depData.id;
        moduleGraph.addDependency(dep);
      }
      for (const normalModuleId of moduleData.modules ?? []) {
        const normalModule = moduleGraph.getModuleById(normalModuleId);
        if (!normalModule) {
          console.warn(
            `Add the ordinary module ID as empty: ${normalModuleId}`
          );
          continue;
        }
        module2.addNormalModule(normalModule);
      }
      for (const concatenationModuleId of moduleData.concatenationModules ?? []) {
        const concatenationModule = moduleGraph.getModuleById(
          concatenationModuleId
        );
        if (!concatenationModule) {
          console.warn(
            `The aggregation module ID is empty: ${concatenationModule}`
          );
          continue;
        }
        module2.addConcatenationModule(concatenationModule);
      }
    }
    for (const exportData of data.exports ?? []) {
      const info = new import_tree_shaking.ExportInfo(
        exportData.name,
        exportData.identifier ? getStatement(exportData.identifier) : void 0
      );
      info.id = exportData.id;
      moduleGraph.addExportInfo(info);
    }
    for (const exportData of data.exports ?? []) {
      if (exportData.from) {
        const current = moduleGraph._exportIdMap.get(exportData.id);
        const from = moduleGraph._exportIdMap.get(exportData.from);
        if (current && from) {
          current.setFromExport(from);
        }
      }
    }
    for (const varData of data.variables ?? []) {
      const module2 = moduleGraph.getModuleById(varData.module);
      if (!module2) {
        console.warn(
          `The module ID in the variable is empty：${varData.module}`
        );
        continue;
      }
      const info = new import_tree_shaking.Variable(
        varData.name,
        module2,
        varData.usedInfo,
        getStatement(varData.identifier)
      );
      const exportInfo = moduleGraph._exportIdMap.get(varData.exported ?? -1);
      if (exportInfo) {
        info.setExportInfo(exportInfo);
      }
      info.id = varData.id;
      moduleGraph.addVariable(info);
    }
    for (const sideData of data.sideEffects ?? []) {
      const module2 = moduleGraph.getModuleById(sideData.module);
      if (!module2) {
        console.warn(
          `The module ID in the side effects is empty：${sideData.module}`
        );
        continue;
      }
      const info = new import_tree_shaking.SideEffect(
        sideData.name,
        module2,
        getStatement(sideData.identifier),
        sideData.originName
      );
      info.isNameSpace = sideData.isNameSpace;
      info.id = sideData.id;
      for (const exportId of sideData.exports ?? []) {
        const exportInfo = moduleGraph._exportIdMap.get(exportId);
        if (exportInfo) {
          exportInfo.addSideEffect(info);
        }
      }
      if (sideData.variable) {
        const varInfo = moduleGraph._varIdMap.get(sideData.variable);
        if (varInfo) {
          info._variable = varInfo;
        }
      }
      moduleGraph.addSideEffect(info);
    }
    for (const mgmData of data.moduleGraphModules ?? []) {
      const module2 = moduleGraph.getModuleById(mgmData.module);
      if (!module2) {
        console.warn(
          `The module ID in ModuleGraphModule is empty: ${mgmData.module}`
        );
        continue;
      }
      const mgm = new import_tree_shaking.ModuleGraphModule(module2, moduleGraph, mgmData.dynamic);
      moduleGraph.addModuleGraphModule(mgm);
      mgmData.exports.forEach((id) => {
        const info = moduleGraph._exportIdMap.get(id);
        if (info) {
          mgm.addExportInfo(info);
        }
      });
      mgmData.sideEffects.forEach((id) => {
        const info = moduleGraph._sideEffectIdMap.get(id);
        if (info) {
          mgm.addSideEffect(info);
        }
      });
      mgmData.variables.forEach((id) => {
        const info = moduleGraph._varIdMap.get(id);
        if (info) {
          mgm.addVariable(info);
        }
      });
    }
    ModuleGraph.init();
    return moduleGraph;
  }
  clear() {
    this._dependenciesIdMap = /* @__PURE__ */ new Map();
    this._moduleWebpackIdMap = /* @__PURE__ */ new Map();
    this._moduleIdMap = /* @__PURE__ */ new Map();
    this._moduleGraphModules = /* @__PURE__ */ new Map();
    this._exportIdMap = /* @__PURE__ */ new Map();
    this._sideEffectIdMap = /* @__PURE__ */ new Map();
    this._varIdMap = /* @__PURE__ */ new Map();
  }
  size() {
    return this._moduleIdMap.size;
  }
  fromInstance(data) {
    this._dependenciesIdMap = new Map(data._dependenciesIdMap);
    this._moduleWebpackIdMap = new Map(data._moduleWebpackIdMap);
    this._moduleIdMap = new Map(data._moduleIdMap);
    this._moduleGraphModules = new Map(data._moduleGraphModules);
    this._exportIdMap = new Map(data._exportIdMap);
    this._sideEffectIdMap = new Map(data._sideEffectIdMap);
    this._varIdMap = new Map(data._varIdMap);
  }
  getSubGraphByModule(module2) {
    const map = /* @__PURE__ */ new Set();
    const result = [module2];
    map.add(module2);
    for (let i = 0; i < result.length; i++) {
      const current = result[i];
      for (const { dependency: depModule } of current.getDependencies()) {
        if (map.has(depModule)) {
          continue;
        }
        map.add(depModule);
        result.push(depModule);
      }
    }
    return result;
  }
  getModules() {
    return Array.from(this._moduleWebpackIdMap.values());
  }
  getDependencies() {
    return Array.from(this._dependenciesIdMap.values());
  }
  getEntryModules() {
    return this.getModules().filter(
      (item) => item.isEntry && item.kind !== import_types.SDK.ModuleKind.Concatenation
    );
  }
  getModuleById(id) {
    return this._moduleIdMap.get(id);
  }
  getDependencyById(id) {
    return this._dependenciesIdMap.get(id);
  }
  getModuleByWebpackId(id) {
    return this._moduleWebpackIdMap.get(id);
  }
  getModuleByFile(file) {
    return this.getModules().find((item) => item.path === file);
  }
  addModule(...modules) {
    for (const module2 of modules) {
      if (!this._moduleIdMap.has(module2.id)) {
        this._moduleWebpackIdMap.set(module2.webpackId, module2);
        this._moduleIdMap.set(module2.id, module2);
      }
    }
  }
  addDependency(...deps) {
    for (const dep of deps) {
      if (!this._dependenciesIdMap.has(dep.id)) {
        this._dependenciesIdMap.set(dep.id, dep);
        this.addModule(dep.module);
        this.addModule(dep.dependency);
      }
    }
  }
  removeModule(module2) {
    this._moduleIdMap.delete(module2.id);
    this._moduleWebpackIdMap.delete(module2.webpackId);
    for (const dep of module2.getDependencies()) {
      this.removeDependency(dep);
      this._dependenciesIdMap.delete(dep.id);
    }
    for (const imported of module2.getImported()) {
      imported.removeDependencyByModule(imported);
    }
  }
  removeDependency(dep) {
    dep.module.removeDependency(dep);
    dep.dependency.removeImported(dep.module);
    this._dependenciesIdMap.delete(dep.id);
  }
  addModuleGraphModule(mgm) {
    if (!this._moduleGraphModules.has(mgm.module)) {
      this._moduleGraphModules.set(mgm.module, mgm);
    }
  }
  getModuleGraphModule(module2) {
    return this._moduleGraphModules.get(module2);
  }
  getModuleGraphModules() {
    return Array.from(this._moduleGraphModules.values());
  }
  addExportInfo(data) {
    this._exportIdMap.set(data.id, data);
  }
  addSideEffect(data) {
    this._sideEffectIdMap.set(data.id, data);
  }
  addVariable(data) {
    this._varIdMap.set(data.id, data);
  }
  toData(configs) {
    return {
      dependencies: this.getDependencies().map((item) => item.toData()),
      modules: this.getModules().map(
        (item) => item.toData(configs?.contextPath)
      ),
      moduleGraphModules: Array.from(this._moduleGraphModules.values()).map(
        (item) => item.toData()
      ),
      exports: Array.from(this._exportIdMap.values()).map(
        (item) => item.toData()
      ),
      sideEffects: Array.from(this._sideEffectIdMap.values()).map(
        (item) => item.toData()
      ),
      variables: Array.from(this._varIdMap.values()).map(
        (item) => item.toData()
      )
    };
  }
  toCodeData(type = import_types.SDK.ToDataType.Normal) {
    const codeMap = {};
    this.getModules().forEach((item) => {
      codeMap[item.id] = item.getSource(type);
    });
    return codeMap;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ModuleGraph
});
