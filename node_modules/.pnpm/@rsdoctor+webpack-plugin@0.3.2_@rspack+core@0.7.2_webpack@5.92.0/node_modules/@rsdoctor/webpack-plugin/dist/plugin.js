"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var plugin_exports = {};
__export(plugin_exports, {
  RsdoctorWebpackPlugin: () => RsdoctorWebpackPlugin
});
module.exports = __toCommonJS(plugin_exports);
var import_plugins = require("@rsdoctor/core/plugins");
var import_graph = require("@rsdoctor/graph");
var import_sdk = require("@rsdoctor/sdk");
var import_types = require("@rsdoctor/types");
var import_build = require("@rsdoctor/utils/build");
var import_logger = require("@rsdoctor/utils/logger");
var import_lodash = require("lodash");
var import_path = __toESM(require("path"));
var import_constants = require("./constants");
var import_resolver = require("./plugins/resolver");
var import_plugins2 = require("@rsdoctor/core/plugins");
var import_common = require("@rsdoctor/utils/common");
class RsdoctorWebpackPlugin {
  constructor(options) {
    this.name = import_constants.pluginTapName;
    this.outsideInstance = false;
    this.browserIsOpened = false;
    this.afterPlugins = (compiler) => {
      if (compiler.isChild())
        return;
      const { plugins, infrastructureLogging, ...rest } = compiler.options;
      const _rest = (0, import_lodash.cloneDeep)(rest);
      (0, import_plugins.makeRulesSerializable)(_rest.module.defaultRules);
      (0, import_plugins.makeRulesSerializable)(_rest.module.rules);
      const configuration = {
        ..._rest,
        plugins: plugins.map((e) => e?.constructor.name)
      };
      const rspackVersion = compiler.webpack?.rspackVersion;
      const webpackVersion = compiler.webpack?.version;
      this.sdk.reportConfiguration({
        name: rspackVersion ? "rspack" : "webpack",
        version: rspackVersion || webpackVersion || "unknown",
        config: configuration
      });
      this.sdk.setOutputDir(
        import_path.default.resolve(compiler.outputPath, `./${import_types.Constants.RsdoctorOutputFolder}`)
      );
      if (configuration.name) {
        this.sdk.setName(configuration.name);
      }
    };
    this.beforeRun = async (compiler) => {
      if (compiler.isChild())
        return;
      await this._bootstrapTask.then(() => {
        if (!this.options.disableClientServer && !this.browserIsOpened) {
          this.browserIsOpened = true;
          this.sdk.server.openClientPage();
        }
      });
    };
    this.done = async () => {
      try {
        this.sdk.server.broadcast();
        (0, import_logger.debug)(import_build.Process.getMemoryUsageMessage, "[Before Write Manifest]");
        await this.sdk.writeStore();
        (0, import_logger.debug)(import_build.Process.getMemoryUsageMessage, "[After Write Manifest]");
        if (this.options.disableClientServer) {
          await this.sdk.dispose();
          (0, import_logger.debug)(import_build.Process.getMemoryUsageMessage, "[After SDK Dispose]");
        }
      } catch (e) {
      }
    };
    this.options = (0, import_plugins.normalizeUserConfig)(options);
    this.sdk = this.options.sdkInstance ?? new import_sdk.RsdoctorWebpackSDK({
      port: this.options.port,
      name: import_constants.pluginTapName,
      root: process.cwd(),
      type: this.options.reportCodeType,
      config: { disableTOSUpload: this.options.disableTOSUpload },
      innerClientPath: this.options.innerClientPath
    });
    this.outsideInstance = Boolean(this.options.sdkInstance);
    this.modulesGraph = new import_graph.ModuleGraph();
    this.chunkGraph = new import_graph.ChunkGraph();
  }
  apply(compiler) {
    if (!this._bootstrapTask) {
      this._bootstrapTask = this.sdk.bootstrap();
    }
    if (!this.outsideInstance) {
      (0, import_plugins.setSDK)(this.sdk);
    }
    new import_plugins.InternalSummaryPlugin(this).apply(compiler);
    if (this.options.features.loader && !import_common.Loader.isVue(compiler)) {
      new import_plugins.InternalLoaderPlugin(this).apply(compiler);
    }
    if (this.options.features.resolver) {
      new import_resolver.InternalResolverPlugin(this).apply(compiler);
    }
    if (this.options.features.plugins) {
      new import_plugins.InternalPluginsPlugin(this).apply(compiler);
    }
    if (this.options.features.bundle) {
      new import_plugins.InternalBundlePlugin(this).apply(compiler);
      new import_plugins.InternalBundleTagPlugin(this).apply(compiler);
    }
    new import_plugins.InternalErrorReporterPlugin(this).apply(compiler);
    new import_plugins.InternalRulesPlugin(this).apply(compiler);
    new import_plugins.InternalProgressPlugin(this).apply(compiler);
    compiler.hooks.afterPlugins.tap(import_constants.pluginTapPostOptions, this.afterPlugins);
    compiler.hooks.watchRun.tapPromise(import_constants.pluginTapPostOptions, this.beforeRun);
    compiler.hooks.beforeRun.tapPromise(import_constants.pluginTapPostOptions, this.beforeRun);
    compiler.hooks.done.tapPromise(
      {
        ...import_constants.pluginTapPostOptions,
        stage: import_constants.pluginTapPostOptions.stage + 100
      },
      this.done.bind(this)
    );
  }
  /**
   * @description Generate ModuleGraph and ChunkGraph from stats and webpack module apis;
   * @param {Compiler} compiler
   * @return {*}
   * @memberof RsdoctorWebpackPlugin
   */
  ensureModulesChunksGraphApplied(compiler) {
    (0, import_plugins2.ensureModulesChunksGraphFn)(compiler, this);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RsdoctorWebpackPlugin
});
