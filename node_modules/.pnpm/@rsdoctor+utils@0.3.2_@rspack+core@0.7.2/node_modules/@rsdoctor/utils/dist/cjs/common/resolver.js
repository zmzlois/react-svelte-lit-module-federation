"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var resolver_exports = {};
__export(resolver_exports, {
  getResolverCosts: () => getResolverCosts,
  getResolverFileDetails: () => getResolverFileDetails,
  getResolverFileTree: () => getResolverFileTree,
  isResolveFailData: () => isResolveFailData,
  isResolveSuccessData: () => isResolveSuccessData
});
module.exports = __toCommonJS(resolver_exports);
var import_algorithm = require("./algorithm");
function isResolveSuccessData(data) {
  return Boolean(data.result);
}
function isResolveFailData(data) {
  return Boolean(data.error);
}
function getResolverCosts(resolver, resolvers) {
  const blocked = resolvers.filter(
    (e) => e !== resolver && e.pid === resolver.pid && e.startAt >= resolver.startAt && e.endAt <= resolver.endAt
  );
  let costs = resolver.endAt - resolver.startAt;
  if (blocked.length) {
    const intervals = blocked.map((e) => [
      Math.max(e.startAt, resolver.startAt),
      Math.min(e.endAt, resolver.endAt)
    ]);
    (0, import_algorithm.mergeIntervals)(intervals).forEach((e) => {
      const sub = e[1] - e[0];
      costs -= sub;
    });
  }
  return costs;
}
function getResolverFileTree(resolver) {
  return resolver.map((e) => ({ issuerPath: e.issuerPath }));
}
function getResolverFileDetails(filepath, resolvers, modules, moduleCodeMap) {
  const module2 = modules.find((item) => item.path === filepath);
  const matchResolvers = resolvers.filter((e) => e.issuerPath === filepath);
  const before = module2 && moduleCodeMap && moduleCodeMap[module2.id] ? moduleCodeMap[module2.id].source : "";
  const after = matchResolvers.reduce((t, c) => {
    if (c.request && isResolveSuccessData(c)) {
      return t.replace(new RegExp(`["']${c.request}["']`), `"${c.result}"`);
    }
    return t;
  }, before);
  return {
    filepath,
    before,
    after,
    resolvers: matchResolvers.map((e) => ({
      ...e,
      costs: getResolverCosts(e, resolvers)
    }))
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getResolverCosts,
  getResolverFileDetails,
  getResolverFileTree,
  isResolveFailData,
  isResolveSuccessData
});
