"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  canParse: () => canParse,
  detectECMAVersion: () => detectECMAVersion,
  getDefaultImports: () => getDefaultImports,
  getIdentifierInDeclaration: () => getIdentifierInDeclaration,
  getIdentifierInExport: () => getIdentifierInExport,
  getIdentifierInImport: () => getIdentifierInImport,
  getIdentifierInPattern: () => getIdentifierInPattern,
  isES5: () => isES5,
  isES6: () => isES6,
  isSameSemantics: () => isSameSemantics
});
module.exports = __toCommonJS(utils_exports);
var import_acorn = require("acorn");
var import_types = require("./types");
var import_asserts = require("./asserts");
function isSameSemantics(node1, node2) {
  if (node1.type !== node2.type) {
    return false;
  }
  switch (node1.type) {
    case "CallExpression": {
      const next = node2;
      return node1.arguments.length === next.arguments.length && Boolean(node1.optional) === Boolean(next.optional) && isSameSemantics(node1.callee, next.callee) && node1.arguments.every(
        (node, i) => isSameSemantics(node, next.arguments[i])
      );
    }
    case "MemberExpression": {
      const next = node2;
      return node1.computed === next.computed && Boolean(node1.optional) === Boolean(next.optional) && isSameSemantics(node1.object, next.object) && isSameSemantics(node1.property, next.property);
    }
    case "Identifier": {
      return node1.name === node2.name;
    }
    case "Literal": {
      if (import_asserts.asserts.isSimpleLiteral(node1) && import_asserts.asserts.isSimpleLiteral(node2)) {
        return node1.value === node2.value;
      }
      return node1.raw === node2.raw;
    }
    case "ObjectExpression": {
      const next = node2;
      return node1.properties.length === next.properties.length && node1.properties.every(
        (prop, i) => isSameSemantics(prop, next.properties[i])
      );
    }
    case "Property": {
      const next = node2;
      return node1.computed === next.computed && node1.kind === next.kind && node1.method === next.method && isSameSemantics(node1.key, next.key) && isSameSemantics(node1.value, next.value);
    }
    default: {
      throw new Error(`Unknown node type: ${node1.type}`);
    }
  }
}
function getDefaultImports(node) {
  return node.body.filter((statement) => {
    if (statement.type !== "ImportDeclaration") {
      return false;
    }
    const specifier = statement?.specifiers?.[0];
    if (specifier?.type === "ImportDefaultSpecifier") {
      return true;
    }
    return false;
  });
}
function getIdentifierInPattern(name, node) {
  if (import_asserts.asserts.isIdentifier(node) && node.name === name) {
    return node;
  }
  if (import_asserts.asserts.isObjectPattern(node)) {
    for (const prop of node.properties) {
      if (import_asserts.asserts.isAssignmentProperty(prop)) {
        return getIdentifierInPattern(name, prop.value);
      }
      if (import_asserts.asserts.isRestElement(prop)) {
        return getIdentifierInPattern(name, prop);
      }
    }
  }
  if (import_asserts.asserts.isArrayPattern(node)) {
    for (const el of node.elements) {
      if (el) {
        const result = getIdentifierInPattern(name, el);
        if (result) {
          return result;
        }
      }
    }
  }
  if (import_asserts.asserts.isRestElement(node)) {
    return getIdentifierInPattern(name, node.argument);
  }
  if (import_asserts.asserts.isAssignmentPattern(node)) {
    return getIdentifierInPattern(name, node.left);
  }
}
function getIdentifierInDeclaration(name, node) {
  function getId(node2) {
    return import_asserts.asserts.isIdentifier(node2.id) && node2.id.name === name ? node2.id : void 0;
  }
  if (import_asserts.asserts.isFunctionDeclaration(node)) {
    return getId(node);
  }
  if (import_asserts.asserts.isClassDeclaration(node)) {
    return getId(node);
  }
  if (import_asserts.asserts.isVariableDeclaration(node)) {
    return node.declarations.find(
      (item) => getIdentifierInPattern(name, item.id)
    )?.id;
  }
}
function getIdentifierInImport(name, node) {
  if (import_asserts.asserts.isImportDeclaration(node)) {
    for (const specifier of node.specifiers ?? []) {
      if (specifier.local.name === name) {
        return specifier.local;
      }
    }
  }
}
function getIdentifierInExport(name, node) {
  if (import_asserts.asserts.isExportNamedDeclaration(node)) {
    if (node.declaration) {
      return getIdentifierInDeclaration(name, node.declaration);
    }
    for (const specifier of node.specifiers ?? []) {
      if (specifier.exported.name === name) {
        return specifier.exported;
      }
    }
  }
  if (import_asserts.asserts.isExportAllDeclaration(node) && node.exported) {
    if (node.exported.name === name) {
      return node.exported;
    }
  }
}
function canParse(code, ecmaVersion2) {
  try {
    (0, import_acorn.parse)(code, {
      ecmaVersion: ecmaVersion2,
      sourceType: typeof ecmaVersion2 === "number" && ecmaVersion2 <= 5 ? "script" : "module"
    });
    return true;
  } catch (err) {
    return false;
  }
}
function isES5(code) {
  return canParse(code, 5);
}
function isES6(code) {
  return canParse(code, 6);
}
function detectECMAVersion(code) {
  if (isES6(code)) {
    if (isES5(code))
      return import_types.ECMAVersion.ES5;
    return import_types.ECMAVersion.ES6;
  }
  return import_types.ECMAVersion.ES7P;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  canParse,
  detectECMAVersion,
  getDefaultImports,
  getIdentifierInDeclaration,
  getIdentifierInExport,
  getIdentifierInImport,
  getIdentifierInPattern,
  isES5,
  isES6,
  isSameSemantics
});
