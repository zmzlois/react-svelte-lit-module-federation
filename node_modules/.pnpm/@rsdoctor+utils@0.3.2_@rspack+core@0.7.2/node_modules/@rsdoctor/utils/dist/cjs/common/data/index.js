"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var data_exports = {};
__export(data_exports, {
  APIDataLoader: () => APIDataLoader
});
module.exports = __toCommonJS(data_exports);
var import_types = require("@rsdoctor/types");
var Loader = __toESM(require("../loader"));
var Resolver = __toESM(require("../resolver"));
var Plugin = __toESM(require("../plugin"));
var Graph = __toESM(require("../graph"));
var Alerts = __toESM(require("../alerts"));
class APIDataLoader {
  constructor(loader) {
    this.loader = loader;
    this.loadAPI = this.loadAPI.bind(this);
  }
  log(...args) {
    console.log(`[${this.constructor.name}]`, ...args);
  }
  loadAPI(...args) {
    const [api, body] = args;
    switch (api) {
      case import_types.SDK.ServerAPI.API.LoadDataByKey:
        return this.loader.loadData(
          body.key
        );
      case import_types.SDK.ServerAPI.API.GetProjectInfo:
        return Promise.all([
          this.loader.loadData("root"),
          this.loader.loadData("pid"),
          this.loader.loadData("hash"),
          this.loader.loadData("summary"),
          this.loader.loadData("configs"),
          this.loader.loadData("envinfo"),
          this.loader.loadData("errors")
        ]).then(
          ([root, pid, hash, summary, configs, envinfo, errors]) => ({ root, pid, hash, summary, configs, envinfo, errors })
        );
      case import_types.SDK.ServerAPI.API.GetClientRoutes:
        return this.loader.loadManifest().then((res) => {
          const { enableRoutes = [] } = res.client || {};
          return enableRoutes;
        });
      case import_types.SDK.ServerAPI.API.GetLoaderNames:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderNames(res || []);
        });
      case import_types.SDK.ServerAPI.API.GetLoaderChartData:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderChartData(res || []);
        });
      case import_types.SDK.ServerAPI.API.GetLoaderFileTree:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderFileTree(res || []);
        });
      case import_types.SDK.ServerAPI.API.GetLoaderFileDetails:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderFileDetails(
            body.path,
            res || []
          );
        });
      case import_types.SDK.ServerAPI.API.GetLoaderFolderStatistics:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderFolderStatistics(
            body.folder,
            res || []
          );
        });
      case import_types.SDK.ServerAPI.API.GetLoaderFileFirstInput:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderFileFirstInput(
            body.file,
            res || []
          );
        });
      case import_types.SDK.ServerAPI.API.GetLoaderFileInputAndOutput:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderFileFirstInput(
            body.file,
            res || []
          );
        });
      case import_types.SDK.ServerAPI.API.GetResolverFileTree:
        return this.loader.loadData("resolver").then((res) => {
          return Resolver.getResolverFileTree(res || []);
        });
      case import_types.SDK.ServerAPI.API.GetResolverFileDetails:
        return Promise.all([
          this.loader.loadData("resolver"),
          this.loader.loadData("moduleGraph.modules"),
          this.loader.loadData("moduleCodeMap")
        ]).then((res) => {
          const resolverData = res[0];
          const modules = res[1];
          const moduleCodeMap = res[2];
          return Resolver.getResolverFileDetails(
            body.filepath,
            resolverData || [],
            modules || [],
            moduleCodeMap || {}
          );
        });
      case import_types.SDK.ServerAPI.API.GetPluginSummary:
        return this.loader.loadData("plugin").then((res) => {
          return Plugin.getPluginSummary(res || {});
        });
      case import_types.SDK.ServerAPI.API.GetPluginData:
        return this.loader.loadData("plugin").then((res) => {
          const { hooks, tapNames } = body;
          return Plugin.getPluginData(res || {}, hooks, tapNames);
        });
      case import_types.SDK.ServerAPI.API.GetAssetsSummary:
        return this.loader.loadData("chunkGraph").then((res) => {
          const { withFileContent = true } = body;
          const { assets = [], chunks = [] } = res || {};
          return Graph.getAssetsSummary(assets, chunks, {
            withFileContent
          });
        });
      case import_types.SDK.ServerAPI.API.GetAssetDetails:
        return Promise.all([
          this.loader.loadData("chunkGraph"),
          this.loader.loadData("moduleGraph")
        ]).then((res) => {
          const { assetPath } = body;
          const { assets = [], chunks = [] } = res[0] || {};
          const { modules = [] } = res[1] || {};
          return Graph.getAssetDetails(assetPath, assets, chunks, modules);
        });
      case import_types.SDK.ServerAPI.API.GetChunksByModuleId:
        return Promise.all([
          this.loader.loadData("chunkGraph"),
          this.loader.loadData("moduleGraph")
        ]).then((res) => {
          const { moduleId } = body;
          const { chunks = [] } = res[0] || {};
          const { modules = [] } = res[1] || {};
          return Graph.getChunksByModuleId(moduleId, modules, chunks);
        });
      case import_types.SDK.ServerAPI.API.GetModuleDetails:
        return Promise.all([
          this.loader.loadData("chunkGraph"),
          this.loader.loadData("moduleGraph")
        ]).then((res) => {
          const { moduleId } = body;
          const { modules = [], dependencies = [] } = res[1] || {};
          return Graph.getModuleDetails(moduleId, modules, dependencies);
        });
      case import_types.SDK.ServerAPI.API.GetModulesByModuleIds:
        return this.loader.loadData("moduleGraph").then((res) => {
          const { moduleIds } = body;
          const { modules = [] } = res || {};
          return Graph.getModuleIdsByModulesIds(moduleIds, modules);
        });
      case import_types.SDK.ServerAPI.API.GetEntryPoints:
        return Promise.all([this.loader.loadData("chunkGraph")]).then((res) => {
          const [chunkGraph] = res;
          const { entrypoints = [] } = chunkGraph || {};
          return Graph.getEntryPoints(entrypoints);
        });
      case import_types.SDK.ServerAPI.API.GetModuleCodeByModuleId:
        return this.loader.loadData("moduleCodeMap").then((moduleCodeMap) => {
          const { moduleId } = body;
          if (moduleCodeMap) {
            return moduleCodeMap[moduleId];
          }
          return { source: "", transformed: "", parsedSource: "" };
        });
      case import_types.SDK.ServerAPI.API.GetModuleCodeByModuleIds:
        return this.loader.loadData("moduleCodeMap").then((moduleCodeMap) => {
          const { moduleIds } = body;
          const _moduleCodeData = {};
          if (moduleCodeMap) {
            moduleIds.forEach((id) => {
              _moduleCodeData[id] = moduleCodeMap[id];
            });
            return _moduleCodeData;
          }
          return [];
        });
      case import_types.SDK.ServerAPI.API.GetAllModuleGraph:
        return this.loader.loadData("moduleGraph").then((moduleGraph) => {
          return moduleGraph?.modules;
        });
      case import_types.SDK.ServerAPI.API.GetAllChunkGraph:
        return this.loader.loadData("chunkGraph").then((chunkGraph) => {
          return chunkGraph?.chunks;
        });
      case import_types.SDK.ServerAPI.API.GetPackageRelationAlertDetails:
        return Promise.all([
          this.loader.loadData("moduleGraph"),
          this.loader.loadData("errors"),
          this.loader.loadData("root"),
          this.loader.loadData("moduleCodeMap")
        ]).then((res) => {
          const { id, target } = body;
          const [moduleGraph, errors = [], root = "", moduleCodeMap] = res;
          const { modules = [], dependencies = [] } = moduleGraph || {};
          const { packages = [] } = errors.find((e) => e.id === id) || {};
          const { dependencies: pkgDependencies = [] } = packages.find(
            (e) => e.target.name === target.name && e.target.root === target.root && e.target.version === target.version
          ) || {};
          return Alerts.getPackageRelationAlertDetails(
            modules,
            dependencies,
            root,
            pkgDependencies,
            moduleCodeMap || {}
          );
        });
      case import_types.SDK.ServerAPI.API.GetOverlayAlerts:
        return this.loader.loadData("errors").then((res) => {
          return (res || []).filter(
            (e) => e.code === import_types.Rule.RuleMessageCodeEnumerated.Overlay
          );
        });
      case import_types.SDK.ServerAPI.API.BundleDiffManifest:
        return this.loader.loadManifest();
      case import_types.SDK.ServerAPI.API.GetBundleDiffSummary:
        return Promise.all([
          this.loader.loadManifest(),
          this.loader.loadData("root"),
          this.loader.loadData("hash"),
          this.loader.loadData("errors"),
          this.loader.loadData("chunkGraph"),
          this.loader.loadData("moduleGraph"),
          this.loader.loadData("moduleCodeMap"),
          this.loader.loadData("packageGraph"),
          this.loader.loadData("configs")
        ]).then(
          ([
            _manifest,
            root = "",
            hash = "",
            errors = {},
            chunkGraph = {},
            moduleGraph = {},
            moduleCodeMap = {},
            packageGraph = {},
            configs = []
          ]) => {
            let outputFilename = "";
            if (typeof configs[0]?.config?.output?.chunkFilename === "string") {
              outputFilename = configs[0]?.config.output.chunkFilename;
            }
            return {
              root,
              hash,
              errors,
              chunkGraph,
              moduleGraph,
              packageGraph,
              outputFilename,
              moduleCodeMap
            };
          }
        );
      case import_types.SDK.ServerAPI.API.GetTileReportHtml:
        return this.loader.loadData("otherReports").then((otherReports) => {
          return otherReports?.tileReportHtml;
        });
      default:
        throw new Error(`API not implement: "${api}"`);
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  APIDataLoader
});
