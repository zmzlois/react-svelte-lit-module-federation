"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var loader_exports = {};
__export(loader_exports, {
  LoaderInternalPropertyName: () => LoaderInternalPropertyName,
  findLoaderTotalTiming: () => findLoaderTotalTiming,
  getLoaderChartData: () => getLoaderChartData,
  getLoaderCosts: () => getLoaderCosts,
  getLoaderFileDetails: () => getLoaderFileDetails,
  getLoaderFileFirstInput: () => getLoaderFileFirstInput,
  getLoaderFileInputAndOutput: () => getLoaderFileInputAndOutput,
  getLoaderFileTree: () => getLoaderFileTree,
  getLoaderFolderStatistics: () => getLoaderFolderStatistics,
  getLoaderNames: () => getLoaderNames,
  getLoadersCosts: () => getLoadersCosts,
  getLoadersTransformData: () => getLoadersTransformData,
  isVue: () => isVue
});
module.exports = __toCommonJS(loader_exports);
var import_algorithm = require("./algorithm");
function findLoaderTotalTiming(loaders) {
  let start = Infinity;
  let end = -Infinity;
  for (let i = 0; i < loaders.length; i++) {
    const loader = loaders[i];
    if (loader.startAt <= start) {
      start = loader.startAt;
    }
    if (loader.endAt >= end) {
      end = loader.endAt;
    }
  }
  return {
    start,
    end
  };
}
function getLoadersCosts(filter, loaders) {
  const match = {};
  const others = {};
  loaders.forEach((e) => {
    if (filter(e)) {
      if (!match[e.pid])
        match[e.pid] = [];
      match[e.pid].push([e.startAt, e.endAt]);
    } else {
      if (!others[e.pid])
        others[e.pid] = [];
      others[e.pid].push([e.startAt, e.endAt]);
    }
  });
  let costs = 0;
  const pids = Object.keys(match);
  for (let i = 0; i < pids.length; i++) {
    const pid = pids[i];
    const _match = (0, import_algorithm.mergeIntervals)(match[pid]);
    const _others = (0, import_algorithm.mergeIntervals)(others[pid] || []).filter(
      ([s, e]) => _match.some((el) => s >= el[0] && e <= el[1])
    );
    const matchSum = _match.length ? _match.reduce((t, c) => t += c[1] - c[0], 0) : 0;
    const othersSum = _others.length ? _others.reduce((t, c) => t += c[1] - c[0], 0) : 0;
    costs += matchSum - othersSum;
  }
  return costs;
}
function getLoaderCosts(loader, loaders) {
  const blocked = loaders.filter((e) => {
    if (e !== loader && e.pid === loader.pid) {
      if (e.startAt >= loader.startAt) {
        if (e.endAt <= loader.endAt)
          return true;
      }
    }
    return false;
  });
  let costs = loader.endAt - loader.startAt;
  if (blocked.length) {
    const intervals = blocked.map((e) => [
      Math.max(e.startAt, loader.startAt),
      Math.min(e.endAt, loader.endAt)
    ]);
    (0, import_algorithm.mergeIntervals)(intervals).forEach((e) => {
      const sub = e[1] - e[0];
      costs -= sub;
    });
  }
  return costs;
}
function getLoaderNames(loaders) {
  const names = /* @__PURE__ */ new Set();
  loaders.forEach((e) => e.loaders.forEach((l) => names.add(l.loader)));
  return [...names];
}
function getLoadersTransformData(loaders) {
  const res = [];
  for (let i = 0; i < loaders.length; i++) {
    const item = loaders[i];
    for (let j = 0; j < item.loaders.length; j++) {
      const loader = item.loaders[j];
      res.push(loader);
    }
  }
  return res;
}
function getLoaderChartData(loaders) {
  const res = [];
  const list = getLoadersTransformData(loaders);
  loaders.forEach((item) => {
    item.loaders.forEach((el) => {
      res.push({
        loader: el.loader,
        isPitch: el.isPitch,
        startAt: el.startAt,
        endAt: el.endAt,
        pid: el.pid,
        sync: el.sync,
        resource: item.resource.path,
        costs: getLoaderCosts(el, list)
      });
    });
  });
  return res;
}
function getLoaderFileTree(loaders) {
  const list = getLoadersTransformData(loaders);
  return loaders.map((data) => {
    const { loaders: arr, resource } = data;
    return {
      path: resource.path,
      loaders: arr.map((l) => {
        return {
          loader: l.loader,
          path: l.path,
          errors: l.errors,
          costs: getLoaderCosts(l, list)
        };
      })
    };
  });
}
function getLoaderFileDetails(path, loaders) {
  const data = loaders.find((e) => e.resource.path === path);
  if (!data) {
    throw new Error(`"${path}" not match any loader data`);
  }
  const list = getLoadersTransformData(loaders);
  return {
    ...data,
    loaders: data.loaders.map((el) => {
      return {
        ...el,
        costs: getLoaderCosts(el, list)
      };
    })
  };
}
function getLoaderFolderStatistics(folder, loaders) {
  const datas = loaders.filter((data) => {
    const { path } = data.resource;
    return path.startsWith(folder);
  });
  const list = getLoadersTransformData(loaders);
  return datas.reduce((t, data) => {
    const { loaders: loaders2 } = data;
    loaders2.forEach((l) => {
      const match = t.find((el) => el.loader === l.loader);
      const costs = getLoaderCosts(l, list);
      if (match) {
        match.files++;
        match.costs += costs;
      } else {
        t.push({
          loader: l.loader,
          path: l.path,
          files: 1,
          costs
        });
      }
    });
    return t;
  }, []);
}
function getLoaderFileFirstInput(file, loaders) {
  for (let i = 0; i < loaders.length; i++) {
    const item = loaders[i];
    if (item.resource.path === file) {
      const nonPitchLoaders = item.loaders.filter((e) => !e.isPitch);
      if (!nonPitchLoaders.length)
        return "";
      return nonPitchLoaders[0].input || "";
    }
  }
  return "";
}
function getLoaderFileInputAndOutput(file, loader, loaderIndex, loaders) {
  for (let i = 0; i < loaders.length; i++) {
    const item = loaders[i];
    if (item.resource.path === file) {
      for (let j = 0; j < item.loaders.length; j++) {
        const l = item.loaders[j];
        if (l.loader === loader && l.loaderIndex === loaderIndex) {
          return {
            input: l.input || "",
            output: l.result || ""
          };
        }
        return {
          input: "",
          output: ""
        };
      }
    }
  }
  return {
    input: "",
    output: ""
  };
}
const LoaderInternalPropertyName = "__l__";
const isVue = (compiler) => {
  const rules = compiler.options.module.rules;
  const hasVueRule = rules.some((rule) => {
    if (rule && typeof rule === "object" && rule.test instanceof RegExp && rule.test?.test(".vue")) {
      return true;
    }
    return false;
  });
  return hasVueRule;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LoaderInternalPropertyName,
  findLoaderTotalTiming,
  getLoaderChartData,
  getLoaderCosts,
  getLoaderFileDetails,
  getLoaderFileFirstInput,
  getLoaderFileInputAndOutput,
  getLoaderFileTree,
  getLoaderFolderStatistics,
  getLoaderNames,
  getLoadersCosts,
  getLoadersTransformData,
  isVue
});
