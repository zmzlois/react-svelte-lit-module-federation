"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var transform_exports = {};
__export(transform_exports, {
  transform: () => transform
});
module.exports = __toCommonJS(transform_exports);
var import_strip_ansi = __toESM(require("strip-ansi"));
var import_types = require("@rsdoctor/types");
var import_error = require("./error");
function isEsbuildError(err) {
  return "pluginName" in err && "text" in err && "location" in err;
}
function isBabelError(err) {
  return "code" in err && "reasonCode" in err;
}
function isDiagnosticError(err) {
  return "severity" in err && "title" in err;
}
function parseBabelErrorMessage(input) {
  const lines = (0, import_strip_ansi.default)(input).split("\n");
  const filePath = lines[0].replace(/^([^:]+):.*/, "$1");
  const message = lines[0].replace(/.*: (.*) \(\d+:\d+\)*/, "$1");
  const lineText = lines.find((line) => line.startsWith("> "))?.replace(/> \d+ \| /, "") ?? "";
  return {
    message,
    filePath,
    lineText
  };
}
function clearMessage(str) {
  return (0, import_strip_ansi.default)(str).replace(/.*: (.*)\n\n[\s\S]*/g, "$1");
}
function clearStack(str) {
  return str.slice(str.indexOf("  at")).replace(/\s*at(.*) \((.*)\)/g, "$1\n$2\n");
}
function transformEsbuildError(err, opt) {
  if (isEsbuildError(err)) {
    const errorCode = opt?.code ?? "ESBUILD_ERROR";
    const speedyError = typeof err.detail === "object" ? import_error.DevToolError.from(err.detail) : new import_error.DevToolError(errorCode, clearMessage(err.text), {
      ...opt,
      hint: err.location?.suggestion,
      codeFrame: {
        filePath: err.text.split(":")[0]
      }
    });
    if (err.location) {
      speedyError.setCodeFrame({
        filePath: err.location.file,
        lineText: err.location.lineText,
        length: err.location.length,
        start: {
          line: err.location.line,
          column: err.location.column + 1
        }
      });
    }
    return speedyError;
  }
}
function transformBabelError(err, opt) {
  if (isBabelError(err)) {
    const errorCode = opt?.code ?? err.code ?? "BABEL";
    const title = err.reasonCode;
    const errorParsed = parseBabelErrorMessage(err.message);
    const speedyError = new import_error.DevToolError(title, errorParsed.message, {
      ...opt,
      code: errorCode,
      stack: err.stack && clearStack(err.stack)
    });
    if (err.loc) {
      speedyError.setCodeFrame({
        ...errorParsed,
        start: {
          line: err.loc.line,
          column: err.loc.column + 1
        }
      });
    }
    return speedyError;
  }
}
function transformNormalError(err, opt) {
  if (err instanceof Error) {
    const stacks = [];
    const filePath = stacks?.[0]?.getFileName?.();
    return new import_error.DevToolError(err.name, clearMessage(err.message), {
      ...opt,
      codeFrame: filePath ? { filePath } : void 0,
      stack: err.stack && clearStack(err.stack)
    });
  }
}
function transformErrorLike(err, opt) {
  const isErrorLike = err && typeof err === "object" && err.message;
  if (isErrorLike) {
    const stacks = [];
    const filePath = stacks?.[0]?.getFileName?.();
    return new import_error.DevToolError(
      err.name || "UNKNOWN_ERROR",
      clearMessage(err.message),
      {
        ...opt,
        codeFrame: filePath ? { filePath } : void 0,
        stack: err.stack && clearStack(err.stack)
      }
    );
  }
}
function transformDiagnostic(err, opt) {
  if (isDiagnosticError(err)) {
    return new import_error.DevToolError(err.title, err.message, {
      ...err,
      ...opt,
      hint: err.suggestions?.description,
      fixData: err.suggestions?.fixData,
      codeFrame: err.document ? {
        filePath: err.document.path,
        fileContent: err.document.content,
        start: err.document.range.start,
        end: err.document.range.end
      } : void 0,
      level: import_types.Linter.Severity[err.severity]
    });
  }
}
function defaultError(err, opt) {
  return new import_error.DevToolError("UNKNOWN_ERROR", JSON.stringify(err), opt);
}
function transform(err, opt) {
  const transformers = [
    transformEsbuildError,
    transformBabelError,
    transformDiagnostic,
    transformNormalError,
    transformErrorLike
  ];
  for (const fn of transformers) {
    const result = fn(err, opt);
    if (result) {
      return result;
    }
  }
  return defaultError(err, opt);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  transform
});
