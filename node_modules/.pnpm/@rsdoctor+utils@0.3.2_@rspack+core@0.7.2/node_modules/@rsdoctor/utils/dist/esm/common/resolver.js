import { mergeIntervals } from "./algorithm";
function isResolveSuccessData(data) {
  return Boolean(data.result);
}
function isResolveFailData(data) {
  return Boolean(data.error);
}
function getResolverCosts(resolver, resolvers) {
  const blocked = resolvers.filter(
    (e) => e !== resolver && e.pid === resolver.pid && e.startAt >= resolver.startAt && e.endAt <= resolver.endAt
  );
  let costs = resolver.endAt - resolver.startAt;
  if (blocked.length) {
    const intervals = blocked.map((e) => [
      Math.max(e.startAt, resolver.startAt),
      Math.min(e.endAt, resolver.endAt)
    ]);
    mergeIntervals(intervals).forEach((e) => {
      const sub = e[1] - e[0];
      costs -= sub;
    });
  }
  return costs;
}
function getResolverFileTree(resolver) {
  return resolver.map((e) => ({ issuerPath: e.issuerPath }));
}
function getResolverFileDetails(filepath, resolvers, modules, moduleCodeMap) {
  const module = modules.find((item) => item.path === filepath);
  const matchResolvers = resolvers.filter((e) => e.issuerPath === filepath);
  const before = module && moduleCodeMap && moduleCodeMap[module.id] ? moduleCodeMap[module.id].source : "";
  const after = matchResolvers.reduce((t, c) => {
    if (c.request && isResolveSuccessData(c)) {
      return t.replace(new RegExp(`["']${c.request}["']`), `"${c.result}"`);
    }
    return t;
  }, before);
  return {
    filepath,
    before,
    after,
    resolvers: matchResolvers.map((e) => ({
      ...e,
      costs: getResolverCosts(e, resolvers)
    }))
  };
}
export {
  getResolverCosts,
  getResolverFileDetails,
  getResolverFileTree,
  isResolveFailData,
  isResolveSuccessData
};
