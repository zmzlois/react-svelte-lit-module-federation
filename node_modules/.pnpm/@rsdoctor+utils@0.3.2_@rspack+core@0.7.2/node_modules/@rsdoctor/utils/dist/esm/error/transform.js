import stripAnsi from "strip-ansi";
import { Linter } from "@rsdoctor/types";
import { DevToolError } from "./error";
function isEsbuildError(err) {
  return "pluginName" in err && "text" in err && "location" in err;
}
function isBabelError(err) {
  return "code" in err && "reasonCode" in err;
}
function isDiagnosticError(err) {
  return "severity" in err && "title" in err;
}
function parseBabelErrorMessage(input) {
  const lines = stripAnsi(input).split("\n");
  const filePath = lines[0].replace(/^([^:]+):.*/, "$1");
  const message = lines[0].replace(/.*: (.*) \(\d+:\d+\)*/, "$1");
  const lineText = lines.find((line) => line.startsWith("> "))?.replace(/> \d+ \| /, "") ?? "";
  return {
    message,
    filePath,
    lineText
  };
}
function clearMessage(str) {
  return stripAnsi(str).replace(/.*: (.*)\n\n[\s\S]*/g, "$1");
}
function clearStack(str) {
  return str.slice(str.indexOf("  at")).replace(/\s*at(.*) \((.*)\)/g, "$1\n$2\n");
}
function transformEsbuildError(err, opt) {
  if (isEsbuildError(err)) {
    const errorCode = opt?.code ?? "ESBUILD_ERROR";
    const speedyError = typeof err.detail === "object" ? DevToolError.from(err.detail) : new DevToolError(errorCode, clearMessage(err.text), {
      ...opt,
      hint: err.location?.suggestion,
      codeFrame: {
        filePath: err.text.split(":")[0]
      }
    });
    if (err.location) {
      speedyError.setCodeFrame({
        filePath: err.location.file,
        lineText: err.location.lineText,
        length: err.location.length,
        start: {
          line: err.location.line,
          column: err.location.column + 1
        }
      });
    }
    return speedyError;
  }
}
function transformBabelError(err, opt) {
  if (isBabelError(err)) {
    const errorCode = opt?.code ?? err.code ?? "BABEL";
    const title = err.reasonCode;
    const errorParsed = parseBabelErrorMessage(err.message);
    const speedyError = new DevToolError(title, errorParsed.message, {
      ...opt,
      code: errorCode,
      stack: err.stack && clearStack(err.stack)
    });
    if (err.loc) {
      speedyError.setCodeFrame({
        ...errorParsed,
        start: {
          line: err.loc.line,
          column: err.loc.column + 1
        }
      });
    }
    return speedyError;
  }
}
function transformNormalError(err, opt) {
  if (err instanceof Error) {
    const stacks = [];
    const filePath = stacks?.[0]?.getFileName?.();
    return new DevToolError(err.name, clearMessage(err.message), {
      ...opt,
      codeFrame: filePath ? { filePath } : void 0,
      stack: err.stack && clearStack(err.stack)
    });
  }
}
function transformErrorLike(err, opt) {
  const isErrorLike = err && typeof err === "object" && err.message;
  if (isErrorLike) {
    const stacks = [];
    const filePath = stacks?.[0]?.getFileName?.();
    return new DevToolError(
      err.name || "UNKNOWN_ERROR",
      clearMessage(err.message),
      {
        ...opt,
        codeFrame: filePath ? { filePath } : void 0,
        stack: err.stack && clearStack(err.stack)
      }
    );
  }
}
function transformDiagnostic(err, opt) {
  if (isDiagnosticError(err)) {
    return new DevToolError(err.title, err.message, {
      ...err,
      ...opt,
      hint: err.suggestions?.description,
      fixData: err.suggestions?.fixData,
      codeFrame: err.document ? {
        filePath: err.document.path,
        fileContent: err.document.content,
        start: err.document.range.start,
        end: err.document.range.end
      } : void 0,
      level: Linter.Severity[err.severity]
    });
  }
}
function defaultError(err, opt) {
  return new DevToolError("UNKNOWN_ERROR", JSON.stringify(err), opt);
}
function transform(err, opt) {
  const transformers = [
    transformEsbuildError,
    transformBabelError,
    transformDiagnostic,
    transformNormalError,
    transformErrorLike
  ];
  for (const fn of transformers) {
    const result = fn(err, opt);
    if (result) {
      return result;
    }
  }
  return defaultError(err, opt);
}
export {
  transform
};
