import { Rule, SDK } from "@rsdoctor/types";
import * as Loader from "../loader";
import * as Resolver from "../resolver";
import * as Plugin from "../plugin";
import * as Graph from "../graph";
import * as Alerts from "../alerts";
class APIDataLoader {
  constructor(loader) {
    this.loader = loader;
    this.loadAPI = this.loadAPI.bind(this);
  }
  log(...args) {
    console.log(`[${this.constructor.name}]`, ...args);
  }
  loadAPI(...args) {
    const [api, body] = args;
    switch (api) {
      case SDK.ServerAPI.API.LoadDataByKey:
        return this.loader.loadData(
          body.key
        );
      case SDK.ServerAPI.API.GetProjectInfo:
        return Promise.all([
          this.loader.loadData("root"),
          this.loader.loadData("pid"),
          this.loader.loadData("hash"),
          this.loader.loadData("summary"),
          this.loader.loadData("configs"),
          this.loader.loadData("envinfo"),
          this.loader.loadData("errors")
        ]).then(
          ([root, pid, hash, summary, configs, envinfo, errors]) => ({ root, pid, hash, summary, configs, envinfo, errors })
        );
      case SDK.ServerAPI.API.GetClientRoutes:
        return this.loader.loadManifest().then((res) => {
          const { enableRoutes = [] } = res.client || {};
          return enableRoutes;
        });
      case SDK.ServerAPI.API.GetLoaderNames:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderNames(res || []);
        });
      case SDK.ServerAPI.API.GetLoaderChartData:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderChartData(res || []);
        });
      case SDK.ServerAPI.API.GetLoaderFileTree:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderFileTree(res || []);
        });
      case SDK.ServerAPI.API.GetLoaderFileDetails:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderFileDetails(
            body.path,
            res || []
          );
        });
      case SDK.ServerAPI.API.GetLoaderFolderStatistics:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderFolderStatistics(
            body.folder,
            res || []
          );
        });
      case SDK.ServerAPI.API.GetLoaderFileFirstInput:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderFileFirstInput(
            body.file,
            res || []
          );
        });
      case SDK.ServerAPI.API.GetLoaderFileInputAndOutput:
        return this.loader.loadData("loader").then((res) => {
          return Loader.getLoaderFileFirstInput(
            body.file,
            res || []
          );
        });
      case SDK.ServerAPI.API.GetResolverFileTree:
        return this.loader.loadData("resolver").then((res) => {
          return Resolver.getResolverFileTree(res || []);
        });
      case SDK.ServerAPI.API.GetResolverFileDetails:
        return Promise.all([
          this.loader.loadData("resolver"),
          this.loader.loadData("moduleGraph.modules"),
          this.loader.loadData("moduleCodeMap")
        ]).then((res) => {
          const resolverData = res[0];
          const modules = res[1];
          const moduleCodeMap = res[2];
          return Resolver.getResolverFileDetails(
            body.filepath,
            resolverData || [],
            modules || [],
            moduleCodeMap || {}
          );
        });
      case SDK.ServerAPI.API.GetPluginSummary:
        return this.loader.loadData("plugin").then((res) => {
          return Plugin.getPluginSummary(res || {});
        });
      case SDK.ServerAPI.API.GetPluginData:
        return this.loader.loadData("plugin").then((res) => {
          const { hooks, tapNames } = body;
          return Plugin.getPluginData(res || {}, hooks, tapNames);
        });
      case SDK.ServerAPI.API.GetAssetsSummary:
        return this.loader.loadData("chunkGraph").then((res) => {
          const { withFileContent = true } = body;
          const { assets = [], chunks = [] } = res || {};
          return Graph.getAssetsSummary(assets, chunks, {
            withFileContent
          });
        });
      case SDK.ServerAPI.API.GetAssetDetails:
        return Promise.all([
          this.loader.loadData("chunkGraph"),
          this.loader.loadData("moduleGraph")
        ]).then((res) => {
          const { assetPath } = body;
          const { assets = [], chunks = [] } = res[0] || {};
          const { modules = [] } = res[1] || {};
          return Graph.getAssetDetails(assetPath, assets, chunks, modules);
        });
      case SDK.ServerAPI.API.GetChunksByModuleId:
        return Promise.all([
          this.loader.loadData("chunkGraph"),
          this.loader.loadData("moduleGraph")
        ]).then((res) => {
          const { moduleId } = body;
          const { chunks = [] } = res[0] || {};
          const { modules = [] } = res[1] || {};
          return Graph.getChunksByModuleId(moduleId, modules, chunks);
        });
      case SDK.ServerAPI.API.GetModuleDetails:
        return Promise.all([
          this.loader.loadData("chunkGraph"),
          this.loader.loadData("moduleGraph")
        ]).then((res) => {
          const { moduleId } = body;
          const { modules = [], dependencies = [] } = res[1] || {};
          return Graph.getModuleDetails(moduleId, modules, dependencies);
        });
      case SDK.ServerAPI.API.GetModulesByModuleIds:
        return this.loader.loadData("moduleGraph").then((res) => {
          const { moduleIds } = body;
          const { modules = [] } = res || {};
          return Graph.getModuleIdsByModulesIds(moduleIds, modules);
        });
      case SDK.ServerAPI.API.GetEntryPoints:
        return Promise.all([this.loader.loadData("chunkGraph")]).then((res) => {
          const [chunkGraph] = res;
          const { entrypoints = [] } = chunkGraph || {};
          return Graph.getEntryPoints(entrypoints);
        });
      case SDK.ServerAPI.API.GetModuleCodeByModuleId:
        return this.loader.loadData("moduleCodeMap").then((moduleCodeMap) => {
          const { moduleId } = body;
          if (moduleCodeMap) {
            return moduleCodeMap[moduleId];
          }
          return { source: "", transformed: "", parsedSource: "" };
        });
      case SDK.ServerAPI.API.GetModuleCodeByModuleIds:
        return this.loader.loadData("moduleCodeMap").then((moduleCodeMap) => {
          const { moduleIds } = body;
          const _moduleCodeData = {};
          if (moduleCodeMap) {
            moduleIds.forEach((id) => {
              _moduleCodeData[id] = moduleCodeMap[id];
            });
            return _moduleCodeData;
          }
          return [];
        });
      case SDK.ServerAPI.API.GetAllModuleGraph:
        return this.loader.loadData("moduleGraph").then((moduleGraph) => {
          return moduleGraph?.modules;
        });
      case SDK.ServerAPI.API.GetAllChunkGraph:
        return this.loader.loadData("chunkGraph").then((chunkGraph) => {
          return chunkGraph?.chunks;
        });
      case SDK.ServerAPI.API.GetPackageRelationAlertDetails:
        return Promise.all([
          this.loader.loadData("moduleGraph"),
          this.loader.loadData("errors"),
          this.loader.loadData("root"),
          this.loader.loadData("moduleCodeMap")
        ]).then((res) => {
          const { id, target } = body;
          const [moduleGraph, errors = [], root = "", moduleCodeMap] = res;
          const { modules = [], dependencies = [] } = moduleGraph || {};
          const { packages = [] } = errors.find((e) => e.id === id) || {};
          const { dependencies: pkgDependencies = [] } = packages.find(
            (e) => e.target.name === target.name && e.target.root === target.root && e.target.version === target.version
          ) || {};
          return Alerts.getPackageRelationAlertDetails(
            modules,
            dependencies,
            root,
            pkgDependencies,
            moduleCodeMap || {}
          );
        });
      case SDK.ServerAPI.API.GetOverlayAlerts:
        return this.loader.loadData("errors").then((res) => {
          return (res || []).filter(
            (e) => e.code === Rule.RuleMessageCodeEnumerated.Overlay
          );
        });
      case SDK.ServerAPI.API.BundleDiffManifest:
        return this.loader.loadManifest();
      case SDK.ServerAPI.API.GetBundleDiffSummary:
        return Promise.all([
          this.loader.loadManifest(),
          this.loader.loadData("root"),
          this.loader.loadData("hash"),
          this.loader.loadData("errors"),
          this.loader.loadData("chunkGraph"),
          this.loader.loadData("moduleGraph"),
          this.loader.loadData("moduleCodeMap"),
          this.loader.loadData("packageGraph"),
          this.loader.loadData("configs")
        ]).then(
          ([
            _manifest,
            root = "",
            hash = "",
            errors = {},
            chunkGraph = {},
            moduleGraph = {},
            moduleCodeMap = {},
            packageGraph = {},
            configs = []
          ]) => {
            let outputFilename = "";
            if (typeof configs[0]?.config?.output?.chunkFilename === "string") {
              outputFilename = configs[0]?.config.output.chunkFilename;
            }
            return {
              root,
              hash,
              errors,
              chunkGraph,
              moduleGraph,
              packageGraph,
              outputFilename,
              moduleCodeMap
            };
          }
        );
      case SDK.ServerAPI.API.GetTileReportHtml:
        return this.loader.loadData("otherReports").then((otherReports) => {
          return otherReports?.tileReportHtml;
        });
      default:
        throw new Error(`API not implement: "${api}"`);
    }
  }
}
export {
  APIDataLoader
};
