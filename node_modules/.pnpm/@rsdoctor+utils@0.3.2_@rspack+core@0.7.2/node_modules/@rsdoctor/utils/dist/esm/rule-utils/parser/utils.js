import { parse } from "acorn";
import { ECMAVersion } from "./types";
import { asserts } from "./asserts";
function isSameSemantics(node1, node2) {
  if (node1.type !== node2.type) {
    return false;
  }
  switch (node1.type) {
    case "CallExpression": {
      const next = node2;
      return node1.arguments.length === next.arguments.length && Boolean(node1.optional) === Boolean(next.optional) && isSameSemantics(node1.callee, next.callee) && node1.arguments.every(
        (node, i) => isSameSemantics(node, next.arguments[i])
      );
    }
    case "MemberExpression": {
      const next = node2;
      return node1.computed === next.computed && Boolean(node1.optional) === Boolean(next.optional) && isSameSemantics(node1.object, next.object) && isSameSemantics(node1.property, next.property);
    }
    case "Identifier": {
      return node1.name === node2.name;
    }
    case "Literal": {
      if (asserts.isSimpleLiteral(node1) && asserts.isSimpleLiteral(node2)) {
        return node1.value === node2.value;
      }
      return node1.raw === node2.raw;
    }
    case "ObjectExpression": {
      const next = node2;
      return node1.properties.length === next.properties.length && node1.properties.every(
        (prop, i) => isSameSemantics(prop, next.properties[i])
      );
    }
    case "Property": {
      const next = node2;
      return node1.computed === next.computed && node1.kind === next.kind && node1.method === next.method && isSameSemantics(node1.key, next.key) && isSameSemantics(node1.value, next.value);
    }
    default: {
      throw new Error(`Unknown node type: ${node1.type}`);
    }
  }
}
function getDefaultImports(node) {
  return node.body.filter((statement) => {
    if (statement.type !== "ImportDeclaration") {
      return false;
    }
    const specifier = statement?.specifiers?.[0];
    if (specifier?.type === "ImportDefaultSpecifier") {
      return true;
    }
    return false;
  });
}
function getIdentifierInPattern(name, node) {
  if (asserts.isIdentifier(node) && node.name === name) {
    return node;
  }
  if (asserts.isObjectPattern(node)) {
    for (const prop of node.properties) {
      if (asserts.isAssignmentProperty(prop)) {
        return getIdentifierInPattern(name, prop.value);
      }
      if (asserts.isRestElement(prop)) {
        return getIdentifierInPattern(name, prop);
      }
    }
  }
  if (asserts.isArrayPattern(node)) {
    for (const el of node.elements) {
      if (el) {
        const result = getIdentifierInPattern(name, el);
        if (result) {
          return result;
        }
      }
    }
  }
  if (asserts.isRestElement(node)) {
    return getIdentifierInPattern(name, node.argument);
  }
  if (asserts.isAssignmentPattern(node)) {
    return getIdentifierInPattern(name, node.left);
  }
}
function getIdentifierInDeclaration(name, node) {
  function getId(node2) {
    return asserts.isIdentifier(node2.id) && node2.id.name === name ? node2.id : void 0;
  }
  if (asserts.isFunctionDeclaration(node)) {
    return getId(node);
  }
  if (asserts.isClassDeclaration(node)) {
    return getId(node);
  }
  if (asserts.isVariableDeclaration(node)) {
    return node.declarations.find(
      (item) => getIdentifierInPattern(name, item.id)
    )?.id;
  }
}
function getIdentifierInImport(name, node) {
  if (asserts.isImportDeclaration(node)) {
    for (const specifier of node.specifiers ?? []) {
      if (specifier.local.name === name) {
        return specifier.local;
      }
    }
  }
}
function getIdentifierInExport(name, node) {
  if (asserts.isExportNamedDeclaration(node)) {
    if (node.declaration) {
      return getIdentifierInDeclaration(name, node.declaration);
    }
    for (const specifier of node.specifiers ?? []) {
      if (specifier.exported.name === name) {
        return specifier.exported;
      }
    }
  }
  if (asserts.isExportAllDeclaration(node) && node.exported) {
    if (node.exported.name === name) {
      return node.exported;
    }
  }
}
function canParse(code, ecmaVersion2) {
  try {
    parse(code, {
      ecmaVersion: ecmaVersion2,
      sourceType: typeof ecmaVersion2 === "number" && ecmaVersion2 <= 5 ? "script" : "module"
    });
    return true;
  } catch (err) {
    return false;
  }
}
function isES5(code) {
  return canParse(code, 5);
}
function isES6(code) {
  return canParse(code, 6);
}
function detectECMAVersion(code) {
  if (isES6(code)) {
    if (isES5(code))
      return ECMAVersion.ES5;
    return ECMAVersion.ES6;
  }
  return ECMAVersion.ES7P;
}
export {
  canParse,
  detectECMAVersion,
  getDefaultImports,
  getIdentifierInDeclaration,
  getIdentifierInExport,
  getIdentifierInImport,
  getIdentifierInPattern,
  isES5,
  isES6,
  isSameSemantics
};
