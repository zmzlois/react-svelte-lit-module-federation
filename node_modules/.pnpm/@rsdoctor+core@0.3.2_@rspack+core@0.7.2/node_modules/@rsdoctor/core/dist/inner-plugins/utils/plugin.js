"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var plugin_exports = {};
__export(plugin_exports, {
  interceptPluginHook: () => interceptPluginHook,
  reportPluginData: () => reportPluginData
});
module.exports = __toCommonJS(plugin_exports);
var import_error = require("@rsdoctor/utils/error");
function reportPluginData(sdk, hook, tapName, start, type, _res, err) {
  const end = Date.now();
  sdk.reportPlugin({
    [hook]: [
      {
        tapName,
        costs: end - start,
        startAt: start,
        endAt: end,
        type,
        result: null,
        // there are circular structure in json
        error: err ? [
          new import_error.DevToolError(`${tapName} ${hook} Error`, err.message, {
            controller: { noStack: false, noColor: true },
            stack: err.stack
          })
        ] : []
      }
    ]
  });
}
function interceptPluginHook(sdk, name, hook) {
  if (!hook.intercept) {
    return;
  }
  hook.intercept({
    register(tap) {
      const o = tap.fn;
      if (tap.type === "sync") {
        tap.fn = function() {
          const start = Date.now();
          try {
            const res = o.apply(this, arguments);
            reportPluginData(sdk, name, tap.name, start, tap.type, res);
            return res;
          } catch (error) {
            reportPluginData(
              sdk,
              name,
              tap.name,
              start,
              tap.type,
              null,
              error
            );
            throw error;
          }
        };
      } else if (tap.type === "async") {
        tap.fn = async function() {
          const start = Date.now();
          try {
            const res = await o.apply(this, arguments);
            reportPluginData(sdk, name, tap.name, start, tap.type, res);
            return res;
          } catch (error) {
            reportPluginData(
              sdk,
              name,
              tap.name,
              start,
              tap.type,
              null,
              error
            );
            throw error;
          }
        };
      } else if (tap.type === "promise") {
        tap.fn = function() {
          const start = Date.now();
          const isChild = arguments?.[0]?.compiler?.isChild();
          return o.apply(this, arguments).then((res) => {
            if (isChild)
              return res;
            reportPluginData(sdk, name, tap.name, start, tap.type, res);
            return res;
          }).catch((error) => {
            reportPluginData(
              sdk,
              name,
              tap.name,
              start,
              tap.type,
              null,
              error
            );
            throw error;
          });
        };
      }
      return tap;
    }
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  interceptPluginHook,
  reportPluginData
});
