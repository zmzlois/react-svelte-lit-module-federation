"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var config_exports = {};
__export(config_exports, {
  makeRuleSetSerializable: () => makeRuleSetSerializable,
  makeRulesSerializable: () => makeRulesSerializable,
  normalizeUserConfig: () => normalizeUserConfig
});
module.exports = __toCommonJS(config_exports);
var import_types = require("@rsdoctor/types");
var import_assert = __toESM(require("assert"));
function defaultBoolean(v, dft) {
  return typeof v === "boolean" ? v : dft;
}
function normalizeUserConfig(config = {}) {
  const {
    linter = {},
    features = {},
    loaderInterceptorOptions = {},
    disableClientServer = false,
    sdkInstance,
    reportCodeType = { noModuleSource: false, noAssetsAndModuleSource: false },
    disableTOSUpload = false,
    innerClientPath = "",
    supports = { parseBundle: true, banner: false },
    port
  } = config;
  (0, import_assert.default)(linter && typeof linter === "object");
  (0, import_assert.default)(features && typeof features === "object");
  (0, import_assert.default)(
    loaderInterceptorOptions && typeof loaderInterceptorOptions === "object"
  );
  (0, import_assert.default)(typeof disableClientServer === "boolean");
  const _features = Array.isArray(
    features
  ) ? {
    loader: features.includes("loader"),
    plugins: features.includes("plugins"),
    resolver: features.includes("resolver"),
    bundle: features.includes("bundle"),
    treeShaking: features.includes("treeShaking"),
    lite: features.includes("lite")
  } : {
    loader: defaultBoolean(features.loader, true),
    plugins: defaultBoolean(features.plugins, true),
    resolver: defaultBoolean(features.resolver, false),
    bundle: defaultBoolean(features.bundle, true),
    treeShaking: defaultBoolean(features.treeShaking, false),
    lite: defaultBoolean(features.lite, false)
  };
  const _linter = {
    rules: {},
    extends: [],
    level: "Error",
    ...linter
  };
  const res = {
    linter: _linter,
    features: _features,
    loaderInterceptorOptions: {
      skipLoaders: Array.isArray(loaderInterceptorOptions.skipLoaders) ? loaderInterceptorOptions.skipLoaders : []
    },
    disableClientServer,
    sdkInstance,
    /**
     * Data storage is divided into three types:
     * The first type: normal mode, all codes are saved.
     * The second type: lite is the same as reportCodeType.noModuleSource, which lacks module source code.
     * The third type: reportCodeType.noAssetsAndModuleSource means there is no module source code nor the packaged product code.
     *
     *  */
    reportCodeType: reportCodeType ? reportCodeType.noModuleSource ? import_types.SDK.ToDataType.Lite : reportCodeType.noAssetsAndModuleSource ? import_types.SDK.ToDataType.LiteAndNoAsset : import_types.SDK.ToDataType.Normal : _features.lite ? import_types.SDK.ToDataType.Lite : import_types.SDK.ToDataType.Normal,
    disableTOSUpload,
    innerClientPath,
    supports,
    port
  };
  return res;
}
function makeRuleSetSerializable(item) {
  if (!item)
    return;
  if (item instanceof RegExp) {
    item.toJSON = item.toString;
  } else if (Array.isArray(item)) {
    item.forEach((i) => makeRuleSetSerializable(i));
  } else if (typeof item === "object") {
    makeRuleSetSerializable(item.and);
    makeRuleSetSerializable(item.or);
    makeRuleSetSerializable(item.not);
  }
}
function makeRulesSerializable(rules) {
  if (!Array.isArray(rules))
    return;
  if (!rules.length)
    return;
  rules.forEach((rule) => {
    if (!rule)
      return;
    makeRuleSetSerializable(rule.test);
    makeRuleSetSerializable(rule.resourceQuery);
    makeRuleSetSerializable(rule.resource);
    makeRuleSetSerializable(rule.resourceFragment);
    makeRuleSetSerializable(rule.scheme);
    makeRuleSetSerializable(rule.issuer);
    if ("issuerLayer" in rule) {
      makeRuleSetSerializable(rule.issuerLayer);
    }
    makeRuleSetSerializable(rule.include);
    makeRuleSetSerializable(rule.exclude);
    if (rule.oneOf) {
      makeRulesSerializable(rule.oneOf);
    }
    if ("rules" in rule && rule.rules) {
      makeRulesSerializable(rule.rules);
    }
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  makeRuleSetSerializable,
  makeRulesSerializable,
  normalizeUserConfig
});
