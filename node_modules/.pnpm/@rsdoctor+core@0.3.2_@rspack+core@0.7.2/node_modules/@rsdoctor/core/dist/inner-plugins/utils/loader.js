"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var loader_exports = {};
__export(loader_exports, {
  getInternalLoaderOptions: () => getInternalLoaderOptions,
  getLoaderOptionsWithoutInternalKeys: () => getLoaderOptionsWithoutInternalKeys,
  getOriginLoaderModule: () => getOriginLoaderModule,
  interceptLoader: () => interceptLoader,
  reportLoader: () => reportLoader,
  shouldSkipLoader: () => shouldSkipLoader
});
module.exports = __toCommonJS(loader_exports);
var import_axios = __toESM(require("axios"));
var import_enhanced_resolve = require("enhanced-resolve");
var import_fs = __toESM(require("fs"));
var import_loader_utils = require("loader-utils");
var import_lodash = require("lodash");
var import_path = __toESM(require("path"));
var import_logger = require("@rsdoctor/utils/logger");
var import_common = require("@rsdoctor/utils/common");
var import_common2 = require("@rsdoctor/utils/common");
var import_types = require("@rsdoctor/types");
var import_error = require("@rsdoctor/utils/error");
var import_sdk = require("./sdk");
var import_circleDetect = require("./circleDetect");
var import_build = require("../../build-utils/build");
function getInternalLoaderOptions(loaderContext) {
  const options = import_build.Utils.getLoaderOptions(loaderContext);
  return options[import_common.Loader.LoaderInternalPropertyName];
}
function getLoaderOptionsWithoutInternalKeys(loaderContext) {
  const options = import_build.Utils.getLoaderOptions(loaderContext);
  const circlePaths = [];
  const loaderOptions = (0, import_lodash.omit)(options, [import_common.Loader.LoaderInternalPropertyName]);
  (0, import_circleDetect.checkCirclePath)(loaderOptions, [], circlePaths, 0);
  if (circlePaths.length > 0) {
    circlePaths.forEach((_path) => {
      if (_path?.length > 0 && loaderOptions[_path[0]] !== "[Circular]") {
        loaderOptions[_path[0]] = "[Circular]";
      }
    });
  }
  return loaderOptions;
}
function getOriginLoaderModule(loaderContext) {
  const { loader, cwd } = getInternalLoaderOptions(loaderContext);
  return import_build.Utils.loadLoaderModule(loader, cwd);
}
function shouldSkipLoader(loaderContext) {
  const { skipLoaders, cwd, loader } = getInternalLoaderOptions(loaderContext) || {};
  if (!loader)
    return true;
  if (Array.isArray(skipLoaders) && skipLoaders.length) {
    if (skipLoaders.includes(loader))
      return true;
    const loaderName = import_build.Utils.extractLoaderName(loader, cwd);
    if (skipLoaders.includes(loaderName))
      return true;
  }
  return false;
}
function interceptLoader(rules, loaderPath, options, cwd = process.cwd(), resolveLoader) {
  const loaderResolver = import_enhanced_resolve.create.sync({
    fileSystem: new import_enhanced_resolve.CachedInputFileSystem(import_fs.default, 4e3),
    conditionNames: ["loader", "require", "node"],
    exportsFields: ["exports"],
    mainFiles: ["index"],
    mainFields: ["loader", "main"],
    extensions: ["js", ".json"],
    modules: ["node_modules"],
    ...resolveLoader
  });
  const resolve = (target) => {
    try {
      const result = loaderResolver({}, cwd, target);
      if (typeof result === "string") {
        return result;
      }
    } catch (e) {
    }
    return target;
  };
  return import_build.Utils.mapEachRules(rules, (rule) => {
    if (rule.loader?.startsWith("builtin:") || rule.loader?.endsWith(".mjs")) {
      return rule;
    }
    const opts = {
      ..."options" in rule ? typeof rule.options === "string" ? JSON.parse(rule.options) : rule.options : {}
    };
    opts[import_common.Loader.LoaderInternalPropertyName] = {
      ...options,
      hasOptions: "options" in rule && Boolean(rule.options),
      loader: "loader" in rule ? resolve(rule.loader) : ""
    };
    return {
      ...rule,
      loader: loaderPath,
      options: opts
    };
  });
}
async function reportLoader(ctx, start, startHRTime, isPitch, sync, code, err, res, sourceMap) {
  const end = import_common2.Time.getCurrentTimestamp(start, startHRTime);
  const { loader, host } = getInternalLoaderOptions(ctx);
  const loaderData = [
    {
      resource: {
        path: ctx.resourcePath,
        query: (0, import_loader_utils.parseQuery)(ctx.resourceQuery || "?"),
        queryRaw: ctx.resourceQuery,
        ext: import_path.default.extname(ctx.resourcePath).slice(1)
      },
      loaders: [
        {
          loader: import_build.Utils.extractLoaderName(loader),
          loaderIndex: ctx.loaderIndex,
          path: loader,
          input: code,
          result: typeof res === "string" || Buffer.isBuffer(res) ? res.toString() : res,
          startAt: start,
          endAt: end,
          options: getLoaderOptionsWithoutInternalKeys(ctx),
          isPitch,
          sync,
          errors: err ? [
            new import_error.DevToolError(code, err.message, {
              controller: { noStack: false, noColor: true },
              stack: err.stack
            })
          ] : [],
          pid: process.pid,
          ppid: process.ppid
        }
      ]
    }
  ];
  const data = !sourceMap ? {} : (0, import_lodash.isString)(sourceMap) ? JSON.parse(sourceMap) : sourceMap;
  const sourceMapData = {
    version: data.version ?? -1,
    sources: data.sources ?? [],
    names: data.names ?? [],
    sourceRoot: data.sourceRoot,
    sourcesContent: data.sourcesContent,
    mappings: data.mappings,
    file: loaderData[0].resource.path
  };
  const sdk = (0, import_sdk.getSDK)();
  if (sdk?.reportLoader && !("parent" in sdk && sdk.parent)) {
    sdk.reportLoader(loaderData);
    sdk.reportSourceMap(sourceMapData);
    return loaderData;
  }
  await Promise.all([
    import_axios.default.post(`${host}${import_types.SDK.ServerAPI.API.ReportLoader}`, loaderData, {
      timeout: 8888
    }).catch((err2) => {
      (0, import_logger.debug)(() => `${err2.message}`, "[WebpackPlugin.ReportLoader][error]");
    }),
    import_axios.default.post(`${host}${import_types.SDK.ServerAPI.API.ReportSourceMap}`, sourceMapData, {
      timeout: 8888
    }).catch((err2) => {
      (0, import_logger.debug)(() => `${err2.message}`, "[WebpackPlugin.ReportSourceMap][error]");
    })
  ]);
  return loaderData;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getInternalLoaderOptions,
  getLoaderOptionsWithoutInternalKeys,
  getOriginLoaderModule,
  interceptLoader,
  reportLoader,
  shouldSkipLoader
});
