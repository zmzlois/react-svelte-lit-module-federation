"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var transform_exports = {};
__export(transform_exports, {
  appendModuleGraphByCompilation: () => appendModuleGraphByCompilation
});
module.exports = __toCommonJS(transform_exports);
var import_build = require("@rsdoctor/utils/build");
var import_compatible = require("../../../common/webpack/compatible");
var import_module_graph = require("../../../common/module-graph");
var import_parser = require("../parser");
var import_lodash = require("lodash");
async function readFile(target, wbFs) {
  if (wbFs?.fs?.readFile) {
    const result = new Promise((resolve, reject) => {
      wbFs.fs.readFile(target, (err, content) => {
        if (err) {
          reject(err);
          return;
        }
        if (content) {
          resolve(Buffer.from(content));
        } else {
          resolve();
        }
      });
    }).catch(() => {
    });
    if (result) {
      return result;
    }
  }
  return import_build.File.fse.readFile(target).catch(() => {
  });
}
function appendDependency(webpackDep, module2, webpackGraph, graph) {
  const resolvedWebpackModule = (0, import_compatible.getResolveModule)(
    webpackDep,
    webpackGraph
  );
  if (!resolvedWebpackModule) {
    return;
  }
  const rawRequest = (0, import_compatible.getWebpackDependencyRequest)(
    webpackDep,
    resolvedWebpackModule
  );
  const resolveRequest = (0, import_compatible.getWebpackModulePath)(resolvedWebpackModule);
  const request = rawRequest ?? resolveRequest;
  if (!module2.getDependencyByRequest(request)) {
    const depModule = graph.getModuleByFile(resolveRequest);
    if (depModule) {
      const dep = module2.addDependency(
        request,
        depModule,
        (0, import_module_graph.getImportKind)(webpackDep)
      );
      if (dep) {
        graph.addDependency(dep);
      }
    }
  }
  const dependency = module2.getDependencyByRequest(request);
  if (dependency) {
    dependency.setBuildMeta({
      exportsType: (0, import_compatible.getModuleExportsType)(
        resolvedWebpackModule,
        webpackGraph,
        module2.meta.strictHarmonyModule
      )
    });
    const statement = (0, import_compatible.getDependencyPosition)(webpackDep, module2, false);
    if (statement) {
      dependency.addStatement(statement);
    }
    dependency.statements.forEach((state) => {
      state.position.source = state.module.getSourceRange(
        state.position.transformed
      );
    });
  }
}
function getModuleSource(modulePath, wbFs, sourceMap) {
  if (sourceMap) {
    try {
      const contentFromSourceMap = sourceMap.sourceContentFor(modulePath);
      if (contentFromSourceMap) {
        return Buffer.from(contentFromSourceMap);
      }
    } catch (e) {
    }
  }
  return process.env.NODE_ENV === "test" ? Buffer.from("test code") : readFile(modulePath, wbFs);
}
async function appendModuleData(origin, webpackGraph, graph, wbFs, features, context) {
  const module2 = graph.getModuleByWebpackId((0, import_compatible.getWebpackModuleId)(origin));
  if (!origin || !module2) {
    return;
  }
  const { getSourceMap, astCache, packagePathMap } = context ?? {};
  try {
    const sourceMap = await getSourceMap?.(module2.path);
    const source = await getModuleSource(module2.path, wbFs, sourceMap) ?? Buffer.from("");
    if (sourceMap) {
      module2.setSourceMap(sourceMap);
    }
    if (astCache?.has(origin)) {
      const program = astCache.get(origin);
      module2.setProgram(program);
      module2.meta.hasSetEsModuleStatement = (0, import_parser.hasSetEsModuleStatement)(program);
    }
    const transformed = (0, import_compatible.isExternalModule)(origin) ? "" : module2.getSource().transformed.length > 0 ? module2.getSource().transformed : (0, import_lodash.isFunction)(origin?.originalSource) ? origin.originalSource()?.source()?.toString() : "";
    const transformedSize = (0, import_compatible.isExternalModule)(origin) ? 0 : module2.getSize().transformedSize > 0 ? module2.getSize().transformedSize : Buffer.from(transformed).byteLength;
    module2.setSource({
      transformed,
      source: source.toString()
    });
    module2.setSize({
      transformedSize,
      sourceSize: source.byteLength
    });
    let packageData;
    if (packagePathMap && origin.resourceResolveData) {
      let { descriptionFileRoot: root } = origin.resourceResolveData;
      const { descriptionFileData: data } = origin.resourceResolveData;
      if (root && data.name && data.version) {
        if (packagePathMap.has(root)) {
          root = packagePathMap.get(root);
        } else {
          const realpath = await import_build.File.fse.realpath(root);
          root = realpath;
          packagePathMap.set(root, realpath);
        }
        packageData = {
          ...origin.resourceResolveData.descriptionFileData,
          root
        };
      }
    }
    module2.meta.strictHarmonyModule = origin.buildMeta?.strictHarmonyModule ?? false;
    module2.meta.packageData = packageData;
    if (!features?.lite && origin?.dependencies) {
      Array.from(origin.dependencies).filter((item) => (0, import_module_graph.isImportDependency)(item)).concat(
        origin.blocks.reduce(
          (ans, item) => ans.concat(item.dependencies),
          []
        )
      ).forEach((dep) => appendDependency(dep, module2, webpackGraph, graph));
    }
  } catch (e) {
    console.error(`module ${module2.path} transform has error:`, e);
  }
}
async function appendModuleGraphByCompilation(compilation, graph, features, context) {
  try {
    const { moduleGraph: webpackGraph, fileSystemInfo } = compilation;
    const allModules = (0, import_compatible.getAllModules)(compilation);
    await Promise.all(
      allModules.map((module2) => {
        return appendModuleData(
          module2,
          webpackGraph,
          graph,
          fileSystemInfo,
          features,
          context
        );
      })
    );
    (0, import_module_graph.removeNoImportStyle)(graph);
    return graph;
  } catch (e) {
    return graph;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  appendModuleGraphByCompilation
});
