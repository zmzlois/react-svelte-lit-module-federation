"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var treeShaking_exports = {};
__export(treeShaking_exports, {
  appendTreeShaking: () => appendTreeShaking
});
module.exports = __toCommonJS(treeShaking_exports);
var import_graph = require("@rsdoctor/graph");
var import_compatible = require("../../common/webpack/compatible");
var import_utils = require("./utils");
var import_module_graph = require("../../common/module-graph");
function transformMgm(origin, webpackGraph, graph, cache) {
  const module2 = graph.getModuleByWebpackId(origin.identifier());
  if (!module2) {
    return;
  }
  const mgm = new import_graph.ModuleGraphModule(module2, graph);
  const originalMgm = webpackGraph.getExportsInfo(origin);
  graph.addModuleGraphModule(mgm);
  for (const info of originalMgm.exports) {
    const { name } = info;
    const exportIdStatement = (0, import_utils.getExportIdentifierStatement)(name, module2) ?? import_graph.Statement.getDefaultStatement(module2);
    const declareIdStatement = (0, import_utils.getDeclarationIdentifier)(name, module2);
    const exportInfo = new import_graph.ExportInfo(info.name, exportIdStatement);
    if (declareIdStatement) {
      const variable = new import_graph.Variable(
        name,
        module2,
        info.getUsedInfo(),
        declareIdStatement
      );
      variable.setExportInfo(exportInfo);
      mgm.addVariable(variable);
    }
    cache.set(info, exportInfo);
    mgm.addExportInfo(exportInfo);
  }
  for (const dep of origin.dependencies) {
    if (dep.type !== "harmony import specifier") {
      continue;
    }
    const HISDep = dep;
    const { name, userRequest } = HISDep;
    const originName = HISDep.getIds(webpackGraph)[0] ?? import_graph.SideEffect.NamespaceSymbol;
    const importIdStatement = module2.getStatement(dep.loc);
    const importInfo = new import_graph.SideEffect(
      name,
      module2,
      importIdStatement,
      userRequest,
      originName
    );
    mgm.addSideEffect(importInfo);
  }
}
function appendExportConnection(origin, webpackGraph, graph, cache) {
  const module2 = graph.getModuleByWebpackId(origin.identifier());
  const mgm = graph.getModuleGraphModule(module2);
  const originalMgm = webpackGraph.getExportsInfo(origin);
  if (!mgm || !module2) {
    return;
  }
  for (const info of originalMgm.exports) {
    if (!info.isReexport()) {
      continue;
    }
    const lastExport = (0, import_compatible.getLastExportInfo)(info, webpackGraph);
    const lastSdkExport = cache.get(lastExport);
    const sdkExport = cache.get(info);
    if (!lastSdkExport || !sdkExport) {
      return;
    }
    sdkExport.setFromExport(lastSdkExport);
  }
}
function appendImportConnection(origin, graph) {
  const module2 = graph.getModuleByWebpackId(origin.identifier());
  const mgm = graph.getModuleGraphModule(module2);
  if (!mgm || !module2) {
    return;
  }
  for (const info of mgm.getSideEffects()) {
    const exportName = info.originName ?? info.name;
    const resolveModule = info.fromDependency?.dependency;
    if (!resolveModule) {
      continue;
    }
    const resolveExport = graph.getModuleGraphModule(resolveModule).getExport(exportName);
    if (resolveExport) {
      info.setExportInfo(resolveExport);
    }
  }
}
function appendTreeShaking(moduleGraph, compilation) {
  if (!(0, import_module_graph.isWebpack5orRspack)(compilation)) {
    return moduleGraph;
  }
  if ("moduleGraph" in compilation) {
    const exportData = /* @__PURE__ */ new Map();
    const { moduleGraph: webpackGraph } = compilation;
    const allModules = (0, import_compatible.getAllModules)(compilation);
    allModules.forEach(
      (origin) => transformMgm(origin, webpackGraph, moduleGraph, exportData)
    );
    allModules.forEach(
      (origin) => appendExportConnection(origin, webpackGraph, moduleGraph, exportData)
    );
    allModules.forEach((origin) => appendImportConnection(origin, moduleGraph));
    exportData.clear();
    return moduleGraph;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  appendTreeShaking
});
