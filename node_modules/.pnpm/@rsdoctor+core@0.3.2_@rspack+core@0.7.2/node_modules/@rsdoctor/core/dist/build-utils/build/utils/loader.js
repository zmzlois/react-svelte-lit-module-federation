"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var loader_exports = {};
__export(loader_exports, {
  addProbeLoader2Rules: () => addProbeLoader2Rules,
  createLoaderContextTrap: () => createLoaderContextTrap,
  extractLoaderName: () => extractLoaderName,
  getLoaderOptions: () => getLoaderOptions,
  loadLoaderModule: () => loadLoaderModule,
  mapEachRules: () => mapEachRules,
  parsePathQueryFragment: () => parsePathQueryFragment
});
module.exports = __toCommonJS(loader_exports);
var import_loader_utils = require("loader-utils");
var import_path = __toESM(require("path"));
var import_lodash = require("lodash");
var import_common = require("@rsdoctor/utils/common");
const PATH_QUERY_FRAGMENT_REGEXP = /^((?:\0.|[^?#\0])*)(\?(?:\0.|[^#\0])*)?(#.*)?$/;
function parsePathQueryFragment(str) {
  const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);
  return {
    path: match?.[1].replace(/\0(.)/g, "$1") || "",
    query: match?.[2] ? match[2].replace(/\0(.)/g, "$1") : "",
    fragment: match?.[3] || ""
  };
}
function loadLoaderModule(loaderPath, cwd = process.cwd()) {
  const cleanLoaderPath = parsePathQueryFragment(loaderPath).path;
  const mod = process.env.DOCTOR_TEST ? require(import_path.default.resolve(cwd, cleanLoaderPath)) : require(require.resolve(cleanLoaderPath, {
    paths: [cwd, import_path.default.resolve(cwd, "node_modules")]
  }));
  const isESM = mod.__esModule && typeof mod.default === "function";
  return {
    default: isESM ? mod.default : typeof mod === "function" ? mod : null,
    pitch: mod.default?.pitch || mod.pitch,
    raw: mod.default?.raw || mod.raw || false
  };
}
function getLoaderOptions(loaderContext) {
  if (typeof loaderContext.getOptions === "function") {
    return loaderContext.getOptions();
  }
  return (0, import_loader_utils.getOptions)(loaderContext);
}
function extractLoaderName(loaderPath, cwd = "") {
  let res = loaderPath.replace(cwd, "");
  if (!import_path.default.isAbsolute(res))
    return res;
  const nms = "/node_modules/";
  const idx = res.lastIndexOf(nms);
  if (idx !== -1) {
    res = res.slice(idx + nms.length);
    const ln = "loader";
    const lnIdx = res.lastIndexOf(ln);
    if (lnIdx > -1) {
      res = res.slice(0, lnIdx + ln.length);
    }
  }
  return res;
}
function mapEachRules(rules, callback) {
  return rules.map((rule) => {
    if (typeof rule === "string") {
      return callback({
        loader: rule
      });
    }
    if (rule.loader && typeof rule.loader === "string") {
      return callback(rule);
    }
    if (Array.isArray(rule.loaders)) {
      const { loaders, ...rest } = rule;
      return {
        ...rest,
        use: mapEachRules(loaders, callback)
      };
    }
    if (rule.use && (!Array.isArray(rule.use) || rule.use.length !== 0)) {
      if (typeof rule.use === "string") {
        return {
          ...rule,
          use: mapEachRules(
            [
              {
                loader: rule.use,
                options: rule.options
              }
            ],
            callback
          )
        };
      }
      if (typeof rule.use === "function") {
        const funcUse = rule.use;
        const newRule = {
          ...rule,
          use: (...args) => {
            const rules2 = funcUse.apply(null, args);
            return mapEachRules(rules2, callback);
          }
        };
        return newRule;
      }
      if (Array.isArray(rule.use)) {
        return {
          ...rule,
          use: mapEachRules(rule.use, callback)
        };
      }
      return {
        ...rule,
        use: mapEachRules([rule.use], callback)
      };
    }
    if ("rules" in rule && Array.isArray(rule.rules)) {
      return {
        ...rule,
        rules: mapEachRules(rule.rules, callback)
      };
    }
    if (Array.isArray(rule.oneOf)) {
      return {
        ...rule,
        oneOf: mapEachRules(rule.oneOf, callback)
      };
    }
    return rule;
  });
}
function getLoaderNameMatch(_r, loaderName, strict = true) {
  if (!strict) {
    return typeof _r === "object" && typeof _r?.loader === "string" && _r.loader.includes(loaderName) || typeof _r === "string" && _r.includes(loaderName);
  }
  return typeof _r === "object" && typeof _r?.loader === "string" && _r.loader === loaderName || typeof _r === "string" && _r === loaderName;
}
function addProbeLoader2Rules(rules, loaderName, appendRules, strict) {
  return rules.map((rule) => {
    if (!rule || typeof rule === "string")
      return rule;
    if (getLoaderNameMatch(rule, loaderName, strict)) {
      const _rule = {
        ...rule,
        use: [
          {
            loader: rule.loader,
            options: rule.options
          }
        ],
        loader: void 0,
        options: void 0
      };
      return appendRules(_rule, 0);
    }
    if (rule.use) {
      if (Array.isArray(rule.use)) {
        const _index = (0, import_lodash.findIndex)(
          rule.use,
          (_r) => getLoaderNameMatch(_r, loaderName, strict)
        );
        if (_index > -1) {
          return appendRules(rule, _index);
        }
      } else if (typeof rule.use === "object" && !Array.isArray(rule.use) && typeof rule.use !== "function") {
        rule.use = [
          {
            ...rule.use
          }
        ];
        return appendRules(rule, 0);
      }
    }
    if ("oneOf" in rule && rule.oneOf) {
      return {
        ...rule,
        oneOf: addProbeLoader2Rules(
          rule.oneOf,
          loaderName,
          appendRules
        )
      };
    }
    if ("rules" in rule && rule.rules) {
      return {
        ...rule,
        rules: addProbeLoader2Rules(
          rule.rules,
          loaderName,
          appendRules
        )
      };
    }
    return rule;
  });
}
function createLoaderContextTrap(final) {
  const cb = this.callback;
  let callback = (...args) => {
    final(args[0], args[1] ?? null, args[2]);
    return cb.call(this, ...args);
  };
  const ac = this.async;
  let async = (...args) => {
    const cb2 = ac(...args);
    return (...args2) => {
      final(args2[0], args2[1] ?? null, args2[2]);
      return cb2(...args2);
    };
  };
  const trap = new Proxy(this, {
    get(target, key, receiver) {
      switch (key) {
        case "async":
          return async;
        case "callback":
          return callback;
        case "query":
          if (target.query) {
            if (typeof target.query === "string") {
              const res = target.query.replace(
                // eslint-disable-next-line no-useless-escape
                new RegExp(
                  `"${import_common.Loader.LoaderInternalPropertyName}":{[^}]*},{0,1}`
                ),
                ""
              );
              return res;
            }
            if (typeof target.query === "object") {
              const options = target.query[import_common.Loader.LoaderInternalPropertyName];
              if (options.hasOptions) {
                return (0, import_lodash.omit)(target.query, [import_common.Loader.LoaderInternalPropertyName]);
              }
              const innerLoaderPath = options?.loader;
              const loaderQuery = parsePathQueryFragment(innerLoaderPath).query;
              return loaderQuery;
            }
          }
          return Reflect.get(target, key, receiver);
        case "getOptions":
          return typeof target.getOptions === "function" ? () => (0, import_lodash.omit)(target.getOptions(), [import_common.Loader.LoaderInternalPropertyName]) : Reflect.get(target, key, receiver);
        default:
          const _target = target;
          return _target[key];
      }
    },
    set(target, key, value, receiver) {
      switch (key) {
        case "async":
          async = value;
          return true;
        case "callback":
          callback = value;
          return true;
        default:
          return Reflect.set(target, key, value, receiver);
      }
    },
    defineProperty(target, p, attrs) {
      return Reflect.defineProperty(target, p, attrs);
    }
  });
  return trap;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addProbeLoader2Rules,
  createLoaderContextTrap,
  extractLoaderName,
  getLoaderOptions,
  loadLoaderModule,
  mapEachRules,
  parsePathQueryFragment
});
