"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var parseBundle_exports = {};
__export(parseBundle_exports, {
  parseBundle: () => parseBundle
});
module.exports = __toCommonJS(parseBundle_exports);
var import_fs = __toESM(require("fs"));
var import_lodash = require("lodash");
var import_bytes = __toESM(require("bytes"));
var import_ruleUtils = require("@rsdoctor/utils/ruleUtils");
var import_path = require("path");
var import_logger = require("@rsdoctor/utils/logger");
const parseBundle = (bundlePath, modulesData) => {
  if (bundlePath.indexOf(".worker.") > 0) {
    return {};
  }
  if ((0, import_path.extname)(bundlePath) !== ".js") {
    return {};
  }
  let content = import_fs.default.readFileSync(bundlePath, "utf8");
  const tagCache = /* @__PURE__ */ new Map();
  let hasBannerPlugin = content.indexOf("RSDOCTOR_START::") > 0;
  if (hasBannerPlugin && !tagCache.get(bundlePath)) {
    const tagMatchResult = getStringBetween(
      content,
      0,
      /([a-z|A-Z]+\.[a-z]+)\(\SRSDOCTOR_START::(.*?);/,
      /([a-z|A-Z]+\.[a-z]+)\(\SRSDOCTOR_END::(.*?)\)/
    );
    content = tagMatchResult.result?.trim() || content;
    tagCache.set(bundlePath, tagMatchResult.loc);
    hasBannerPlugin = true;
  } else if (hasBannerPlugin && !tagCache.get(bundlePath)) {
    const loc = tagCache.get(bundlePath);
    content = content.slice(loc.start, loc.end);
    hasBannerPlugin = true;
  }
  const ast = import_ruleUtils.parser.internal.parse(content, {
    sourceType: "script",
    ecmaVersion: "latest"
  });
  const walkState = {
    locations: null,
    expressionStatementDepth: 0
  };
  import_ruleUtils.parser.walk.recursive(ast, walkState, {
    ExpressionStatement(node, state, c) {
      if (state.locations)
        return;
      state.expressionStatementDepth++;
      try {
        if (
          // Webpack 5 stores modules in the the top-level IIFE
          state.expressionStatementDepth === 1 && // ast?.range?.includes(node) &&
          isIIFE(node)
        ) {
          const fn = getIIFECallExpression(node);
          if (
            // It should not contain neither arguments
            fn.arguments.length === 0 && // ...nor parameters
            fn.callee.params.length === 0
          ) {
            const firstVariableDeclaration = fn.callee.body.body.find(
              (node2) => node2.type === "VariableDeclaration"
            );
            if (firstVariableDeclaration) {
              for (const declaration of firstVariableDeclaration.declarations) {
                if (declaration.init) {
                  state.locations = getModulesLocations(declaration.init);
                  if (state.locations) {
                    break;
                  }
                }
              }
            }
          }
        }
        if (!state.locations) {
          c(node.expression, state);
        }
      } catch (e) {
        (0, import_logger.debug)(() => e);
      }
      state.expressionStatementDepth--;
    },
    Program(node, state, _c) {
      if (state.locations)
        return;
      try {
        if (hasBannerPlugin) {
          const firstVariableDeclaration = node.body.find(
            (node2) => {
              return node2.type === "VariableDeclaration" && node2.declarations?.[0]?.init?.type === "ObjectExpression" && node2.declarations?.[0]?.init?.properties?.length;
            }
          );
          if (firstVariableDeclaration) {
            for (const declaration of firstVariableDeclaration.declarations) {
              if (declaration.init) {
                state.locations = getModulesLocations(declaration.init);
                if (state.locations) {
                  break;
                }
              }
            }
          }
        }
        if (!state.locations) {
          node.body.forEach((n) => _c(n, state));
        }
      } catch (e) {
        (0, import_logger.debug)(() => e);
      }
      state.expressionStatementDepth--;
    },
    AssignmentExpression(node, state) {
      if (state.locations)
        return;
      const { left, right } = node;
      if (left?.object && left.object.name === "exports" && left.property && left.property.name === "modules" && isModulesHash(right)) {
        state.locations = getModulesLocations(right);
      }
    },
    CallExpression(node, state, c) {
      if (state.locations)
        return;
      const args = node.arguments;
      if (node.callee.type === "FunctionExpression" && !node.callee.id && args.length === 1 && isSimpleModulesList(args[0])) {
        state.locations = getModulesLocations(args[0]);
        return;
      }
      if (node.callee.type === "Identifier" && mayBeAsyncChunkArguments(args) && isModulesList(args[1])) {
        state.locations = getModulesLocations(args[1]);
        return;
      }
      if (isAsyncChunkPushExpression(node)) {
        state.locations = getModulesLocations(args[0].elements[1]);
        return;
      }
      if (isAsyncWebWorkerChunkExpression(node)) {
        state.locations = getModulesLocations(args[1]);
        return;
      }
      args.forEach((arg) => c(arg, state));
    }
  });
  let modules;
  if (walkState.locations) {
    modules = (0, import_lodash.mapValues)(
      walkState.locations,
      (loc) => content.slice(loc.start, loc.end)
    );
  } else {
    modules = {};
  }
  const modulesObj = {};
  for (const module2 in modules) {
    if (!module2) {
      return {};
    }
    const moduleContent = modules[module2];
    const size = moduleContent && Buffer.byteLength(moduleContent);
    const _filterModules = (0, import_lodash.find)(modulesData, {
      id: Number(module2)
    });
    const identifier = _filterModules?.identifier || (0, import_lodash.find)(modulesData, { id: module2 })?.identifier || "";
    modulesObj[identifier] = {
      size,
      sizeConvert: (0, import_bytes.default)(size || 0),
      content: moduleContent
    };
  }
  return {
    modules: modulesObj,
    src: content,
    runtimeSrc: getBundleRuntime(content, walkState.locations)
  };
};
function getBundleRuntime(content, modulesLocations) {
  const sortedLocations = Object.values(modulesLocations || {}).sort(
    (a, b) => a.start - b.start
  );
  let result = "";
  let lastIndex = 0;
  for (const { start, end } of sortedLocations) {
    result += content.slice(lastIndex, start);
    lastIndex = end;
  }
  return result + content.slice(lastIndex, content.length);
}
function isIIFE(node) {
  return node.type === "ExpressionStatement" && (node.expression.type === "CallExpression" || node.expression.type === "UnaryExpression" && node.expression.argument.type === "CallExpression");
}
function getIIFECallExpression(node) {
  if (node.expression.type === "UnaryExpression") {
    return node.expression.argument;
  }
  return node.expression;
}
function isModulesList(node) {
  return isSimpleModulesList(node) || // Modules are contained in expression `Array([minimum ID]).concat([<module>, <module>, ...])`
  isOptimizedModulesArray(node);
}
function isSimpleModulesList(node) {
  return (
    // Modules are contained in hash. Keys are module ids.
    isModulesHash(node) || // Modules are contained in array. Indexes are module ids.
    isModulesArray(node)
  );
}
function isModulesHash(node) {
  return node.type === "ObjectExpression" && node.properties.map((node2) => node2.value).every(isModuleWrapper);
}
function isModulesArray(node) {
  return node.type === "ArrayExpression" && node.elements.every(
    (elem) => (
      // Some of array items may be skipped because there is no module with such id
      !elem || isModuleWrapper(elem)
    )
  );
}
function isOptimizedModulesArray(node) {
  return node.type === "CallExpression" && node.callee.type === "MemberExpression" && // Make sure the object called is `Array(<some number>)`
  node.callee.object.type === "CallExpression" && node.callee.object.callee.type === "Identifier" && node.callee.object.callee.name === "Array" && node.callee.object.arguments.length === 1 && isNumericId(node.callee.object.arguments[0]) && // Make sure the property X called for `Array(<some number>).X` is `concat`
  node.callee.property.type === "Identifier" && node.callee.property.name === "concat" && // Make sure exactly one array is passed in to `concat`
  node.arguments.length === 1 && isModulesArray(node.arguments[0]);
}
function isModuleWrapper(node) {
  return (
    // It's an anonymous function expression that wraps module
    (node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression") && !node.id || // If `DedupePlugin` is used it can be an ID of duplicated module...
    isModuleId(node) || // or an array of shape [<module_id>, ...args]
    node.type === "ArrayExpression" && node.elements.length > 1 && isModuleId(node.elements[0])
  );
}
function isModuleId(node) {
  return node.type === "Literal" && (isNumericId(node) || typeof node.value === "string");
}
function isNumericId(node) {
  return node.type === "Literal" && Number.isInteger(node.value) && node.value >= 0;
}
function isChunkIds(node) {
  return node.type === "ArrayExpression" && node.elements.every(isModuleId);
}
function isAsyncChunkPushExpression(node) {
  const { callee, arguments: args } = node;
  return callee.type === "MemberExpression" && callee.property.name === "push" && callee.object.type === "AssignmentExpression" && args.length === 1 && args[0].type === "ArrayExpression" && mayBeAsyncChunkArguments(args[0].elements) && isModulesList(args[0].elements[1]);
}
function mayBeAsyncChunkArguments(args) {
  return args.length >= 2 && isChunkIds(args[0]);
}
function isAsyncWebWorkerChunkExpression(node) {
  const { callee, type, arguments: args } = node;
  return type === "CallExpression" && callee.type === "MemberExpression" && args.length === 2 && isChunkIds(args[0]) && isModulesList(args[1]);
}
function getModulesLocations(node) {
  if (node.type === "ObjectExpression") {
    const modulesNodes = node.properties;
    return modulesNodes.reduce(
      (result, moduleNode) => {
        const moduleId = moduleNode.key.name || moduleNode.key.value;
        result[moduleId] = getModuleLocation(moduleNode.value);
        return result;
      },
      {}
    );
  }
  const isOptimizedArray = node.type === "CallExpression";
  if (node.type === "ArrayExpression" || isOptimizedArray) {
    const minId = isOptimizedArray ? (
      // Get the [minId] value from the Array() call first argument literal value
      node.callee.object.arguments[0].value
    ) : (
      // `0` for simple array
      0
    );
    const modulesNodes = isOptimizedArray ? (
      // The modules reside in the `concat()` function call arguments
      node.arguments[0].elements
    ) : node.elements;
    return modulesNodes.reduce(
      (result, moduleNode, i) => {
        if (moduleNode) {
          result[i + minId] = getModuleLocation(moduleNode);
        }
        return result;
      },
      {}
    );
  }
  return {};
}
function getModuleLocation(node) {
  return {
    start: node.start,
    end: node.end
  };
}
function getStringBetween(raw, position, start, end) {
  try {
    const matchStart = raw.match(start);
    const startFlagIndex = matchStart?.length ? raw.indexOf(matchStart[0], position) : -1;
    if (startFlagIndex === -1 || !matchStart?.length) {
      return {
        result: null,
        remain: position
      };
    }
    const startTagLength = matchStart[0].length;
    const matchEnd = raw.match(end);
    const endFlagIndex = matchEnd?.length ? raw.indexOf(matchEnd[0], startFlagIndex + startTagLength) : -1;
    if (endFlagIndex === -1 || !matchEnd?.length) {
      return {
        result: null,
        remain: position
      };
    }
    let innerContent = raw.slice(startFlagIndex + startTagLength, endFlagIndex).trim();
    if (innerContent.endsWith(",")) {
      innerContent = innerContent.slice(0, -1);
    }
    return {
      result: innerContent,
      remain: matchEnd?.length ? endFlagIndex + matchEnd[0].length : endFlagIndex,
      loc: {
        start: startFlagIndex + startTagLength,
        end: endFlagIndex
      }
    };
  } catch (e) {
    (0, import_logger.debug)(() => e);
    return {
      result: null,
      remain: position
    };
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  parseBundle
});
