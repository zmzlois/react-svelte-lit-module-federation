"use strict";
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3b/lib/util/fs.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mkdirp = exports.rmrf = void 0;
const assert_1 = __importDefault(require("assert"));
const path_1 = __importDefault(require("path"));
function rmrf(fs, p, callback) {
    fs.stat(p, (err, stats) => {
        if (err) {
            if (err.code === "ENOENT") {
                return callback();
            }
            return callback(err);
        }
        if (stats.isDirectory()) {
            fs.readdir(p, (err, files) => {
                if (err) {
                    return callback(err);
                }
                let count = files.length;
                if (count === 0) {
                    fs.rmdir(p, callback);
                }
                else {
                    files.forEach(file => {
                        (0, assert_1.default)(typeof file === "string");
                        const fullPath = join(fs, p, file);
                        rmrf(fs, fullPath, err => {
                            if (err) {
                                return callback(err);
                            }
                            count--;
                            if (count === 0) {
                                fs.rmdir(p, callback);
                            }
                        });
                    });
                }
            });
        }
        else {
            fs.unlink(p, callback);
        }
    });
}
exports.rmrf = rmrf;
const join = (fs, rootPath, filename) => {
    if (fs && fs.join) {
        return fs.join(rootPath, filename);
    }
    else if (path_1.default.posix.isAbsolute(rootPath)) {
        return path_1.default.posix.join(rootPath, filename);
    }
    else if (path_1.default.win32.isAbsolute(rootPath)) {
        return path_1.default.win32.join(rootPath, filename);
    }
    else {
        throw new Error(`${rootPath} is neither a posix nor a windows path, and there is no 'join' method defined in the file system`);
    }
};
const dirname = (fs, absPath) => {
    if (fs && fs.dirname) {
        return fs.dirname(absPath);
    }
    else if (path_1.default.posix.isAbsolute(absPath)) {
        return path_1.default.posix.dirname(absPath);
    }
    else if (path_1.default.win32.isAbsolute(absPath)) {
        return path_1.default.win32.dirname(absPath);
    }
    else {
        throw new Error(`${absPath} is neither a posix nor a windows path, and there is no 'dirname' method defined in the file system`);
    }
};
const mkdirp = (fs, p, callback) => {
    fs.mkdir(p, err => {
        if (err) {
            if (err.code === "ENOENT") {
                const dir = dirname(fs, p);
                if (dir === p) {
                    callback(err);
                    return;
                }
                (0, exports.mkdirp)(fs, dir, err => {
                    if (err) {
                        callback(err);
                        return;
                    }
                    fs.mkdir(p, err => {
                        if (err) {
                            if (err.code === "EEXIST") {
                                callback();
                                return;
                            }
                            callback(err);
                            return;
                        }
                        callback();
                    });
                });
                return;
            }
            else if (err.code === "EEXIST") {
                callback();
                return;
            }
            callback(err);
            return;
        }
        callback();
    });
};
exports.mkdirp = mkdirp;
