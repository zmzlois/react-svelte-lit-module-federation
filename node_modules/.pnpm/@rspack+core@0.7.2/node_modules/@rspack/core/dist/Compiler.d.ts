/// <reference types="node" />
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3bb53f36a5b8fc6bc1bd976ed7af161bd80/lib/Compiler.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
import * as binding from "@rspack/binding";
import * as tapable from "tapable";
import { Callback } from "tapable";
import type Watchpack from "../compiled/watchpack";
import { Compilation, CompilationParams } from "./Compilation";
import { ContextModuleFactory } from "./ContextModuleFactory";
import { RuleSetCompiler } from "./RuleSetCompiler";
import { Stats } from "./Stats";
import { EntryNormalized, OutputNormalized, RspackOptionsNormalized, RspackPluginInstance } from "./config";
import { rspack } from "./index";
import * as liteTapable from "./lite-tapable";
import ResolverFactory = require("./ResolverFactory");
import Cache = require("./lib/Cache");
import CacheFacade = require("./lib/CacheFacade");
import { Source } from "webpack-sources";
import { Chunk } from "./Chunk";
import { FileSystemInfoEntry } from "./FileSystemInfo";
import { NormalModuleFactory } from "./NormalModuleFactory";
import { Watching } from "./Watching";
import { Logger } from "./logging/Logger";
import { OutputFileSystem, WatchFileSystem } from "./util/fs";
export interface AssetEmittedInfo {
    content: Buffer;
    source: Source;
    outputPath: string;
    targetPath: string;
    compilation: Compilation;
}
declare class Compiler {
    #private;
    hooks: {
        done: tapable.AsyncSeriesHook<Stats>;
        afterDone: tapable.SyncHook<Stats>;
        thisCompilation: liteTapable.SyncHook<[Compilation, CompilationParams]>;
        compilation: liteTapable.SyncHook<[Compilation, CompilationParams]>;
        invalid: tapable.SyncHook<[string | null, number]>;
        compile: tapable.SyncHook<[CompilationParams]>;
        normalModuleFactory: tapable.SyncHook<NormalModuleFactory>;
        contextModuleFactory: tapable.SyncHook<ContextModuleFactory>;
        initialize: tapable.SyncHook<[]>;
        shouldEmit: liteTapable.SyncBailHook<[Compilation], boolean>;
        infrastructureLog: tapable.SyncBailHook<[string, string, any[]], true>;
        beforeRun: tapable.AsyncSeriesHook<[Compiler]>;
        run: tapable.AsyncSeriesHook<[Compiler]>;
        emit: liteTapable.AsyncSeriesHook<[Compilation]>;
        assetEmitted: liteTapable.AsyncSeriesHook<[string, AssetEmittedInfo]>;
        afterEmit: liteTapable.AsyncSeriesHook<[Compilation]>;
        failed: tapable.SyncHook<[Error]>;
        shutdown: tapable.AsyncSeriesHook<[]>;
        watchRun: tapable.AsyncSeriesHook<[Compiler]>;
        watchClose: tapable.SyncHook<[]>;
        environment: tapable.SyncHook<[]>;
        afterEnvironment: tapable.SyncHook<[]>;
        afterPlugins: tapable.SyncHook<[Compiler]>;
        afterResolvers: tapable.SyncHook<[Compiler]>;
        make: liteTapable.AsyncParallelHook<[Compilation]>;
        beforeCompile: tapable.AsyncSeriesHook<[CompilationParams]>;
        afterCompile: tapable.AsyncSeriesHook<[Compilation]>;
        finishMake: liteTapable.AsyncSeriesHook<[Compilation]>;
        entryOption: tapable.SyncBailHook<[string, EntryNormalized], any>;
    };
    webpack: typeof rspack;
    name?: string;
    parentCompilation?: Compilation;
    root: Compiler;
    outputPath: string;
    running: boolean;
    idle: boolean;
    resolverFactory: ResolverFactory;
    infrastructureLogger: any;
    watching?: Watching;
    inputFileSystem: any;
    intermediateFileSystem: any;
    outputFileSystem: OutputFileSystem | null;
    watchFileSystem: WatchFileSystem | null;
    records: Record<string, any[]>;
    modifiedFiles?: ReadonlySet<string>;
    removedFiles?: ReadonlySet<string>;
    fileTimestamps?: ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null>;
    contextTimestamps?: ReadonlyMap<string, FileSystemInfoEntry | "ignore" | null>;
    fsStartTime?: number;
    watchMode: boolean;
    context: string;
    cache: Cache;
    compilerPath: string;
    options: RspackOptionsNormalized;
    constructor(context: string, options: RspackOptionsNormalized);
    get recordsInputPath(): never;
    get recordsOutputPath(): never;
    get managedPaths(): never;
    get immutablePaths(): never;
    get _lastCompilation(): Compilation | undefined;
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     * @internal
     */
    get __internal__builtinPlugins(): binding.BuiltinPlugin[];
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     * @internal
     */
    get __internal__ruleSet(): RuleSetCompiler;
    /**
     * @param name - cache name
     * @returns the cache facade instance
     */
    getCache(name: string): CacheFacade;
    /**
     * @param name - name of the logger, or function called once to get the logger name
     * @returns a logger with that name
     */
    getInfrastructureLogger(name: string | (() => string)): Logger;
    /**
     * @param watchOptions - the watcher's options
     * @param handler - signals when the call finishes
     * @returns a compiler watcher
     */
    watch(watchOptions: Watchpack.WatchOptions, handler: Callback<Error, Stats>): Watching;
    /**
     * @param callback - signals when the call finishes
     */
    run(callback: Callback<Error, Stats>): void;
    runAsChild(callback: (err?: null | Error, entries?: Chunk[], compilation?: Compilation) => any): void;
    purgeInputFileSystem(): void;
    /**
     * @param compilation - the compilation
     * @param compilerName - the compiler's name
     * @param compilerIndex - the compiler's index
     * @param outputOptions - the output options
     * @param plugins - the plugins to apply
     * @returns a child compiler
     */
    createChildCompiler(compilation: Compilation, compilerName: string, compilerIndex: number, outputOptions: OutputNormalized, plugins: RspackPluginInstance[]): Compiler;
    isChild(): boolean;
    compile(callback: Callback<Error, Compilation>): void;
    close(callback: (error?: Error | null) => void): void;
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     * @internal
     */
    __internal__rebuild(modifiedFiles?: ReadonlySet<string>, removedFiles?: ReadonlySet<string>, callback?: (error: Error | null) => void): void;
    __internal__registerBuiltinPlugin(plugin: binding.BuiltinPlugin): void;
    __internal__getModuleExecutionResult(id: number): any;
}
export { Compiler };
